{
  "name": "file-manifest",
  "description": "Require all the files in a directory into a single object",
  "version": "1.0.3",
  "author": {
    "name": "mantacode",
    "email": "code@manta.com",
    "url": "www.manta.com"
  },
  "contributors": [
    {
      "name": "Andrew Nichols",
      "email": "anichols@manta.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/mantacode/file-manifest.git"
  },
  "homepage": "https://github.com/mantacode/file-manifest",
  "scripts": {
    "test": "grunt",
    "publish": "if echo $USERNAME | grep -cq 'anichols'; then publisher run; fi"
  },
  "dependencies": {
    "async": "^0.9.0",
    "caller-id": "^0.1.0",
    "lodash": "^2.4.1",
    "pedestrian": "0.0.9",
    "underscore.string": "^2.3.3",
    "varity": "^1.0.2"
  },
  "devDependencies": {
    "coffee-script": "^1.8.0",
    "grunt": "^0.4.5",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-mocha-cov": "^0.3.0",
    "grunt-mocha-test": "^0.11.0",
    "grunt-travis-matrix": "^0.0.3",
    "indeed": "^1.0.6",
    "jshint-stylish": "^0.4.0",
    "mocha": "git://github.com/tandrewnichols/mocha.git#suppress-stack",
    "mocha-given": "git://github.com/tandrewnichols/mocha-given.git",
    "mocha-lcov-reporter": "0.0.1",
    "proxyquire": "^1.0.1",
    "sinon": "^1.10.3"
  },
  "keywords": [
    "collect",
    "coalesce",
    "require",
    "directory",
    "dir",
    "build",
    "manifest",
    "all"
  ],
  "main": "./lib/file-manifest",
  "engines": {
    "node": ">=0.8.0"
  },
  "config": {
    "blanket": {
      "pattern": [
        "file-manifest/lib"
      ]
    }
  },
  "readme": "[![Build Status](https://travis-ci.org/mantacode/file-manifest.png)](https://travis-ci.org/mantacode/file-manifest) [![downloads](http://img.shields.io/npm/dm/file-manifest.svg)](https://npmjs.org/package/file-manifest) [![npm](http://img.shields.io/npm/v/file-manifest.svg)](https://npmjs.org/package/file-manifest) [![Code Climate](https://codeclimate.com/github/mantacode/file-manifest/badges/gpa.svg)](https://codeclimate.com/github/mantacode/file-manifest) [![Test Coverage](https://codeclimate.com/github/mantacode/file-manifest/badges/coverage.svg)](https://codeclimate.com/github/mantacode/file-manifest) [![dependencies](https://david-dm.org/mantacode/file-manifest.png)](https://david-dm.org/mantacode/file-manifest)\n\n[![NPM info](https://nodei.co/npm/file-manifest.png?downloads=true)](https://nodei.co/npm/file-manifest.png?downloads=true)\n\n# File-Manifest\n\nRequire all the files in a directory into a single object\n\n## Installation\n\n`npm install file-manifest --save`\n\n## Usage\n\nFile-manifest recursively requires everything in a given directory (optionally filtered with globstar patterns) and packages it into a single object where the keys are (by default) camel-cased file names. Thus if you had a directory called `foo`, whose structure looked like this:\n\n```\nbar\nbaz\n  quux\n  some-long-name\n```\n\nYou'd end up with an object that looked like this:\n\n```javascript\n{\n  fooBar: // foo/bar's exports\n  fooBazQuux: //foo/baz/quux's exports\n  fooBazSomeLongName: // foo/baz/some-long-name's exports\n}\n```\n\nThis is useful (for example) in an express app to create a route manifest:\n\n```javascript\nvar routes = require('file-manifest').generate('routes');\n\napp.get('/', routes.home);\napp.get('/users/:id', routes.profile);\n// etc.\n```\n\nor a middleware manifest:\n\n```javascript\nvar middleware = require('file-manifest').generate('middleware');\n\napp.use(middleware.setOriginPolicy);\napp.use(middleware.defaultLogger);\n// etc.\n```\n\nor in a mongoose app to load all models:\n\n```javascript\nvar models = require('file-manifest').generate('models');\nmodule.exports = function(req, res, next) {\n  req.models = models;\n  next();\n};\n```\n\n### Sync\n\nAs demonstrated above, just call `.generate` with a relative or absolute path.\n\n```javascript\nvar manifest = require('file-manifest').generate('some/dir');\n```\n\n### Async\n\nJust like sync, but accepts a callback. It is important that the first argument to this function start with `err` (more on this below).\n\n```javascript\nrequire('file-manifest').generate('some/dir', function(err, manifest) {\n  // . . .\n});\n```\n\n### With Patterns\n\nBoth sync and async versions accept a string pattern or list of string patterns to filter (see [minimatch](https://github.com/isaacs/minimatch) for more on globstar patterns).\n\n```javascript\nvar manifest = require('file-manifest').generate('config', '**/*.json');\n\n// or\n\nrequire('file-manifest').generate('config', ['**/*.json', '**/*.yml'], function(err, manifest) {\n  // . . .\n});\n```\n\n### With a Custom Reduce\n\nFile-manifest also gives you the option to provide a custom reduce function. This let's you alter the behavior of `file-manifest` if simply requiring the files is insufficient (or you don't like camel-cased key names). This reduce function (as of v1.0.0) has the following signature - `(options, manifest, fileObj, [callback])` - where `options` is an object in the form:\n\n```javascript\npatterns: Array or String // Any matching patterns provided (or empty string if none)\ndir: String // The directory to search\nmemo: Any // The starting value for the reduce function (defaults to {})\nreducer: String or Function // The reduce function to call\nrequire: String or Function // The function to get the current file (defaults to the build in require function)\nnamer: String or Function // The function to name the keys in the manifest\n```\n\n`manifest` is the results of the reduce process so far (often called \"memo\" for reasons that aren't really clear to me), `fileObj` is an object of file parts in the form:\n\n```javascript\nrelativePath: String // The path of the file minus the original path (e.g. \"foo/bar.js\")\nrelativeName: String // Like relativePath but without the extension. This is the part used for naming the keys (e.g. \"foo/bar\")\nfullPath: String // The full path of the file (e.g. \"/dir/foo/bar.js\")\nbasename: String // The result of path.basename(fullPath) (e.g. \"bar.js\")\nname: String // Like basename but without the extension (e.g. \"bar\")\next: String // The file extension (e.g. \".js\")\n```\n\nThe callback will, of course, only be available in async implementations. You should manipulate the manifest and then return it (sync) or call the callback with an optional error and the new manifest (async).\n\n```javascript\nvar manifest = require('file-manifest').generate('keywords', function(options, manifest, file) {\n  var name = file.relativeName.split('/').join('|');\n  manifest[name] = require(file.fullPath);\n  return manifest;\n});\n```\n\nThe sync implemenation uses `_.reduce` ([underscore](http://underscorejs.org/)), while the async version uses `async.reduce` ([async](https://github.com/caolan/async)), so see those for more information.\n\nYou might have noted that the same `generate` function can take a reduce function, a callback, or both. The way `file-manifest` distinguishes is by examining the last function to see if it's first parameter begins with `err`. That's why all async implementations should pass a callback that accepts a variable named `err` or `error`.\n\nIf you are still using `file-manifest@<1.x`, the custom reduce function should accept only `manifest`, `file`, and (optionally) `callback`. The `file` is the absolute file path. The context of the function (i.e. `this`) does have properties called `dir`, which is the originally passed in path, and patterns, which is the original patterns. This just means you need to do some of the manipulation yourself. For example, the above function would be:\n\n```javascript\nvar manifest = require('file-manifest').generate('keywords', function(manifest, file) {\n  var name = file.replace(this.dir + '/', '').replace(path.extname(file), '').split('/').join('|');\n  manifest[name] = require(file);\n  return manifest;\n});\n```\n\n### With options\n\nAs of `file-manifest@1.0.0`, you can also pass an `options` object to file-manifest. The options object can have any of the following keys:\n\n#### Patterns and Reducer\n\nSame as the parameter counterparts above.\n\nThese can be passed as part of the object OR as separate parameters. If you're passing an options object, you should just add them to that. The separate parameters were only included to preserve (the appearance of) backward compatibility (v1.0.0 is not _really_ backward compatible, but it takes a lot less to convert an old implementation with these parameters preserved).\n\n#### Memo\n\n`memo` is the starting value for the reduce function. The default is `{}`, but it is sometimes useful to use `[]` or even something more complicated. Note, however, that the default reduce function expects an object, so if you want to do something different, you should supply a custom reducer. E.g.\n\n```javascript\nvar manifest = require('file-manifest').generate('client/app/js', { memo: [], patterns: ['**/*.js'], reducer: function(options, manifest, file) {\n  manifest.push(file.name);\n  return manifest;\n}});\n```\n\n#### Require and Namer\n\nIf you only want custom functionality for the way keys are generated or the way the file is read, you can also pass either (or both) of `namer` and `require`. The `namer` function should accept the options object and the same file object that `reduce` accepts and should return the key name. The `require` function should accept `options`, `fileObj`, and optionally `callback` and should return the corresponding value for the key (usually the exports or file contents) for sync implementations or call the callback with an optional error and the value for async implementations.\n\n```javascript\nvar manifest = require('file-manifest').generate('partials', { namer: function(options, file) { return file.relativeName.split('/').join('-'); }, require: function(options, file, cb) {\n  fs.readFile(file.fullPath, 'utf8', cb);\n}});\n```\n\nAlternatively, since there are some common patterns, `namer` can be a string - one of `camelCase` (the default), `dash`, `slash`, `pipe`, `class`, `lower`, `upper`, `underscore` or `snake`, or `human`. The results for the file \"foo/bar.js\" for each would be:\n\n```\ncamelCase: \"fooBar\",\ndash: \"foo-bar\",\nslash: \"foo/bar\",\npipe: \"foo|bar\",\nclass: \"FooBar\",\nlower: \"foobar\",\nupper: \"FOOBAR\",\nunderscore: \"foo_bar\",\nsnake: \"foo_bar\",\nhuman: \"Foo bar\"\n```\n\nSimilarly, the `require` option can be a string with either `require` or `readFile`. `require` will use node's `require` function (this is the default, so there's not much point in specifying this). `readFile` will use `readFileSync` (for sync implementations) or `readFile` (for async implementations).\n\nSo the previous call to `file-manifest` could be replaced with\n\n```javascript\nvar manifest = require('file-manifest').generate('partials', { namer: 'dash', require: 'readFile' });\n```\n<br><br><br>\n*Note: This _probably_ goes without saying, but \"an optional error\" (throughout) means that it may be `null` or `undefined`, not that it may be omitted.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mantacode/file-manifest/issues"
  },
  "_id": "file-manifest@1.0.3",
  "_shasum": "89daf643861cfd910d9a5050702d7701e24f39cc",
  "_from": "file-manifest@"
}
