{
  "name": "varity",
  "description": "A simple wrapper to make variable length arities easier to manage",
  "version": "1.0.3",
  "author": {
    "name": "Andrew Nichols",
    "email": "anichols@manta.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/tandrewnichols/varity.git"
  },
  "homepage": "https://www.tandrewnichols.me/modules/varity",
  "bugs": {
    "url": "https://github.com/tandrewnichols/varity/issues"
  },
  "license": "MIT",
  "scripts": {
    "test": "grunt"
  },
  "dependencies": {
    "config-extend": "0.0.7",
    "safe-obj": "^1.0.2",
    "underscore": "^1.7.0"
  },
  "devDependencies": {
    "coffee-script": "^1.8.0",
    "grunt": "^0.4.5",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-mocha-cov": "^0.3.0",
    "grunt-mocha-test": "^0.12.1",
    "grunt-travis-matrix": "0.0.4",
    "indeed": "^1.0.6",
    "jshint-stylish": "^1.0.0",
    "mocha": "^1.21.5",
    "mocha-given": "^0.1.3",
    "mocha-lcov-reporter": "0.0.1",
    "proxyquire": "^1.0.1",
    "sinon": "^1.10.3"
  },
  "keywords": [
    "arity",
    "arguments",
    "parameters"
  ],
  "main": "./lib",
  "engines": {
    "node": ">=0.8.0"
  },
  "config": {
    "blanket": {
      "pattern": [
        "varity/lib"
      ]
    }
  },
  "readme": "[![Build Status](https://travis-ci.org/tandrewnichols/varity.png)](https://travis-ci.org/tandrewnichols/varity) [![downloads](http://img.shields.io/npm/dm/varity.svg)](https://npmjs.org/package/varity) [![npm](http://img.shields.io/npm/v/varity.svg)](https://npmjs.org/package/varity)\n\n# Varity\n\nJavascript arity simplified.\n\n## Why?\n\nThe ability to pass a variable number of parameters to functions is a nice feature of javascript, but it can sometimes lead to boilerplate code at the top of a method to determine which parameters you're actually working with. Something like\n\n```javascript\nfunction (url, params, options, callback) {\n  if (typeof params === 'function') {\n    callback = params, params = {}, options = {};\n  } else if (typeof options === 'function') {\n    callback = options, options = {};\n  }\n  // . . . now for actual function logic\n}\n```\n\nVarity (\"variable-arity\") handles this for you. And it can do some other handy things to.\n\n## Install\n\n`npm install varity --save`\n\n## Basic Use\n\nWhen you `require('varity')`, you'll get a wrapper function back. This wrapper accepts a set of expectations and the function to wrap, then handles boilerplate arity shenanigans for you. If you tell varity you're expecting a string and a number, but only pass it a number, varity will fill in the string argument with `undefined`. No need to test `if (typeof options === 'function')`. There are several ways to tell varity what you're expecting.\n\n### With types\n\n```javascript\nvar $ = require('varity');\nvar wrapped = $(Array, Function, function(list, callback) {\n  // list is guaranteed to be an array or undefined\n  // callback will always be a function or undefined\n});\n\n// For example\nwrapped([1, 2, 3]); // the function will be called with [1, 2, 3] and undefined\n\n// or\nwrapped(function() {}); // undefined, function() {}\n\n// any additional params will also be passed on\nwrapped([1, 2, 3], function() {}, { foo: 'bar' }) // [1, 2, 3], function() {}, { foo: 'bar' }\n\n// in fact, varity is smart enough to handle this:\nwrapped([1, 2, 3], { foo: 'bar' }) // [1, 2, 3], undefined, { foo: 'bar' }\n\n// and even\nwrapped({ foo: 'bar'}) // undefined, undefined, { foo: 'bar'}\n```\n\nYou can pass any object type (use `null` for Null and `undefined` for Undefined - though there's not much value in expecting these in functions). You can also pass custom types.\n\n```javascript\nfunction Foo () {}\nvar wrapped = $(Foo, function(foo) {\n  // We have a foo!\n});\n```\n\n### With an array\n\n```javascript\nvar wrapped = $(['String', 'Function'], function(name, callback) {\n  // . . .\n});\n```\n\nThis let's you compile argument lists on the fly if necessary.\n\n```javascript\nvar args = ['String'];\nif (opts.async) {\n  args.push('Function');\n}\n\nvar wrapped = $.apply($, [args, function(path, cb){\n  // Do neat stuff\n}]);\n```\n\n### With a string\n\nThe first two methods are useful, but also lengthy. The real value in varity is in string abbreviations. To keep calls to varity short, all built in types have one character analogs that can be passed collectively as a single string:\n\n```javascript\nvar wrapped = $('ssf', function(fname, lname, callback) {\n  // . . . \n});\n```\n\nThe following abbreviations are currently recognized by varity:\n\n* s: String\n* f: Function\n* o: Object\n* a: Array\n* 1: Number\n* b: Boolean\n* r: RegExp\n* d: Date\n* N: NaN\n* n: Null\n* u: Undefined\n* A: Arguments\n* i: Infinity\n* e: Error\n* E: Element\n* $: jQuery\n\nAdditionally, strings can have array wrappers (`[s]`) and ors (`|`). Any letter wrapped in `[]` tells varity to wrap the arg (if it matches that type) in an array. `|` says that either of two types are acceptable. These can also be combined.\n\n```javascript\nvar wrapped = $('[s]', function(list) {\n  // When called with a string, arguments will be an array with that string as the first and only item\n});\n\nvar wrapped = $('1|b', function(isTruthy) {\n  // Either a number or boolean can be passed\n});\n\nvar wrapped = $('[s]|a', function(list) {\n  // Either a string (which will be wrapped) or an array can be passed\n});\n\nvar wrapped = $('[s]|[1]', function(list) {\n  // Either a string or number can be passed, but in either case, it will be wrapped as an array\n});\n```\n\n## Flags\n\nKnowing that `options` will never be a function is nice, but you might still need to check for definedness before doing something with a parameter:\n\n```javascript\nvar wrapped = $('af', function(list, cb) {\n  cb(list.concat(['foo', 'bar']);\n});\n\nwrapped(function(newList) { /* . . . */ }); // Uh, oh. Cannot call method concat of undefined.\n```\n\nThus, varity has some flags, indicated with symbols, that tell it to handle awkward conditions, such as the above, gracefully.\n\n### Populate: +\n\nTells varity to return a default of the given type so that you don't have to worry about calling type specific methods.\n\n```javascript\nvar wrapped = $('+a', function(list) {\n  list.push('something'); // list will ALWAYS be an array\n}\n```\n\nThe built in defaults are as follows (though you can override them - more on that later).\n\n* String\n\n```javascript\n''\n```\n\n* Function\n\n```javascript\nfunction(){}\n```\n\n* Object\n\n```javascript\n{}\n```\n\n* Array\n\n```javascript\n[]\n```\n\n* Number\n\n```javascript\n0\n```\n\n* Boolean\n\n```javascript\nfalse\n```\n\n* RegExp\n\n```javascript\n/.*/\n```\n\n* Date\n\n```javascript\n(function() {\n  return new Date();\n})()\n```\n\n* NaN\n\n```javascript\nNaN\n```\n\n* Null\n\n```javascript\nnull\n```\n\n* Undefined\n\n```javascript\nundefined\n```\n\n* Arguments: \n\n```javascript\n(function(){\n  return arguments;\n})(undefined)\n```\n\n* Infinity\n\n```javascript\n2/0 // because I like the number 2\n```\n\n* Error: \n\n```javascript\n(function() {\n  return new Error();\n})()\n```\n\n* Element:\n\n```javascript\n(function() {\n  if (typeof window !== 'undefined') {\n    return window.document;\n  } else {\n    return '<div></div>';\n  }\n})()\n```\n\n* jQuery:\n\n```javascript\n(function() {\n  if (typeof $ !== 'undefined') {\n    return $(document);\n  } else {\n    return [];\n  }\n})()\n```\n\n### Optional: -\n\nNormally, if you pass two of the same type next to each other, Varity will assign the first parameter that matches that type to the first argument and leave the second undefined.\n\n```javascript\nvar wrapped = $('oo', function(options, data) {\n  // If only one object is passed, it will be passed as \"options\" and \"data\" will be undefined\n});\n```\n\nThe `optional` flag reverses this behavior. (Alternatively, you could just reverse the parameters: `function(data, options)`.)\n\n```javascript\nvar wrapped = $('-oo', function(options, data) {\n  // Now if only one object is passed, it'll be set to \"data\", leaving \"options\" undefined.\n});\n```\n\nYou can also combine `populate` with `optional`:\n\n```javascript\nvar wrapped = $('-+oo', function(obj1, obj2) {\n  // If passed only {foo: 'bar'}, arguments will be {}, {foo: 'bar'}\n});\n```\n\n### Non-empty: _\n\nThe non-empty flag tells varity to treat \"empty\" parameters as if they were undefined. This isn't that useful unless you change the defaults (more below). If you tell varity to populate a type with some other default and use the _ flag, varity will replace an empty type (e.g. `{}`, `[]`, `function() {}`, etc.) with the default of that type.\n\n```javascript\n$.populate('Object', {\n  dataType: 'json',\n  method: 'put'\n});\n\nvar wrapped = $('s_o', function(url, opts) {\n  // see below for more about populate\n});\nwrapped('something.com', {}); // Provides 'something.com' and { dataType: 'json', method: 'put' }\n```\n\n### Required: *\n\nMarks a parameter as required. If that parameter is not passed, Varity will throw an exception.\n\n```javascript\nvar wrapped = $('*so', function(name, options) {\n  // . . .\n});\nwrapped({ async: true }); // throws\n```\n\n### Extend: &\n\nFor matching types, the actual argument will be extended with additional defaults. For objects, this means a deep object extend; for arrays, concat; for strings, joining with \" \"; and for functions, calling `_.compose` (with the default function coming first in the composition). This is an excellent way to handle option extension.\n\n```javascript\n$.extend('Object', { async: true }); // See \"Helpers\" below\nvar wrapped = $('&o', function(options) { });\nwrapped({ path: '/foo/bar' }); // options will equal { async: true, path: '/foo/bar' }\n\n$.extend('Array', [ 'Chuck' ]);\nvar wrapped = $('&a', function(ppl) { });\nwrapped([ 'Sue', 'Douglas' ]); // ppl will equal [ 'Sue', 'Douglas', 'Chuck' ]\n\n$.extend('String', 'Please try again.');\nvar wrapped = $('&s', function(message) { });\nwrapped('We were unable to update your profile.'); // message will equal 'We were unable to update your profile. Please try again.'\n\n$.extend('Function', function(name) { return 'My name is ' + name; });\nvar wrapped = $('&f', function(fn) { });\nwrapped(function(message) { console.log(message); }); // when \"fn\" is called with \"Tim\", \"My name is Tim\" will be logged\n```\n\n## Helpers\n\nVarity also a couple helper methods for changing options.\n\n### varity.configure\n\nUse `varity.configure` for one time, initial setup. All calls to `varity()` after that will use whatever options you pass. You can pass the following options to `varity.configure`:\n\n* letters - add custom abbreviations or override default ones\n* symbols - additional symbols and their corresponding functions\n* defaults - override built in defaults or provide defaults for custom types\n* populate - turn on `populate` for all types (with `true`) or a set of types (with an array) so that you don't have to use the `+` flag\n \n```javascript\nvar $ = require('varity');\n$.configure({\n  letters: {\n    '~': 'Foo',\n    'a': 'Array',\n    'g': 'Arguments' // If you don't like dealing with captials \n  },\n  symbols: {\n    '!': function(arg, context) {\n      return !!arg;\n    }\n  },\n  defaults: {\n    'Object': {\n      jsonp: true,\n      method: 'get',\n      data: {\n        user: localStorage.get('user')\n      }\n    },\n    'Foo': function() {\n      return new Foo('my foo param');\n    }\n  },\n  populate: true // Always populate ALL types\n\n  /*\n   * OR\n   *\n   * populate: ['Object', 'Array', 'Foo']\n   *\n   * to always populate ONLY these types\n   */\n});\n```\n\nNote that these options will be used for EVERY call to varity. If you need to undo these options, you can call `varity.reset()`, which will restore the defaults. However, any already wrapped functions will still have the custom options.\n\nThere are also simplified helpers that set one-time options:\n\n### varity.letters\n\n```javascript\n$.letters('q', 'Quux');\n```\n\n### varity.symbols\n\n```javascript\n$.symbols('!', function(arg, context) {\n  return !!arg;\n});\n```\n\n### varity.defaults\n\n```javascript\n$.defaults('Array', [1, 2, 3]);\n```\n\n### varity.populate\n\n```javascript\n$.populate('Array', [1, 2, 3]);\n\n// or\n\n$.populate('Array');\n\n// or\n\n$.populate(true);\n```\n\nUnlike the others, which simply set the corresponding option, varity.populate both adds the type to the `populate` list _and_ calls $.defaults when called with two arguments (since, for a one-time option, it's essentially implied that the populating thing should be used). When called with only a type, that type is added to the `populate` list, but no additional default is set. When called with `true`, all types will be populated by default.\n\n### varity.extend\n\n```javascript\n$.extend('Object', { async: true, path: '/foo/bar' });\n```\n\n## Custom Symbols\n\nEach symbol corresponds to a function that receives the current argument and a context. The context looks like this:\n\n```javascript\n{\n  symbols: ['-', '+'], // a list of symbols passed with this argument\n  types: ['String'], // a list of types to match against\n  wrapType: 'array' // indicates whether [] or | were used in the string\n}\n```\n\nIn addition, the varity object is passed as the `this` context, so you can access things like `this.args`, which has the full set of arguments passed to varity. You can create custom functionality by adding symbols and manipulating one or both of these parameters. Use this to whatever destructive ends you see fit. Note that symbol operations are called in the order in which they're passed, which _can_ make a difference. For instance, if you want to use `+` and `-` together, you should always pass `-` first, since, after `+` runs, the current argument will _never_ be undefined (well, unless the expected type is `undefined`). The example in the `configure` section above coerces results to booleans. You can take a look at the existing symbol operations to get an idea of how to use the context object.\n",
  "readmeFilename": "README.md",
  "_id": "varity@1.0.3",
  "_shasum": "f6fdb7cb8e017fa259711d5a06a2b78893bed5d6",
  "_from": "varity@^1.0.2"
}
