// Generated by CoffeeScript 1.6.3
var Graph, Join, Neo4j, Neo4jRestful, Node, Path, Relationship, Transaction, client, configForTest, expect, generateUID, helpers, neo4jmapper, _, _ref;

if (typeof root !== "undefined" && root !== null) {
  require('source-map-support').install();
  expect = require('expect.js');
  Join = require('join');
  _ = require('underscore');
  configForTest = require('./config');
  Neo4j = require("../" + configForTest.srcFolder + "/index.js");
  _ref = new Neo4j({
    url: configForTest.neo4jURL,
    onConnectionError: function(err) {
      throw err;
    }
  }), Graph = _ref.Graph, Node = _ref.Node, Relationship = _ref.Relationship, Path = _ref.Path, Transaction = _ref.Transaction, Neo4jRestful = _ref.Neo4jRestful, helpers = _ref.helpers, client = _ref.client;
} else {
  _ = window._;
  configForTest = _.extend({
    doLog: false,
    wipeDatabase: false,
    neo4jURL: 'http://yourserver:0000/'
  }, configForTest || {});
  Join = window.Join;
  neo4jmapper = new window.Neo4jMapper(configForTest.neo4jURL);
  Graph = neo4jmapper.Graph, Node = neo4jmapper.Node, Relationship = neo4jmapper.Relationship, Path = neo4jmapper.Path, Transaction = neo4jmapper.Transaction, Neo4jRestful = neo4jmapper.Neo4jRestful, helpers = neo4jmapper.helpers, client = neo4jmapper.client;
  Neo4j = Neo4jMapper;
}

if (configForTest.doLog) {
  client.constructor.prototype.log = Graph.prototype.log = configForTest.doLog;
}

generateUID = function() {
  return String(new Date().getTime()) + String(Math.round(Math.random() * 10000000));
};

describe('Neo4jMapper (transaction)', function() {
  it('create new open transaction', function(done) {
    var params, query, t;
    query = 'START n=node(*) MATCH (n)-[r]-() RETURN n, r LIMIT {l}';
    params = {
      l: 1
    };
    t = new Transaction();
    t = new Transaction(query, params);
    expect(t.neo4jrestful.absoluteUrl()).to.be.a('string');
    expect(t.status).to.be('new');
    return new Transaction(query, params, function(err, transaction) {
      expect(err).to.be(null);
      expect(transaction.status).to.be('open');
      return transaction.close(function(err, t) {
        expect(t.status).to.be('committed');
        return done();
      });
    });
  });
  it('expect to create, add statements and close a transaction', function(done) {
    var paramsWith, query, t;
    query = 'CREATE (n {props}) RETURN n AS node, id(n) AS id';
    paramsWith = function(name) {
      return {
        props: {
          name: name
        }
      };
    };
    t = new Transaction(query, paramsWith('Foo Fighters')).add(query, paramsWith('Metallica'));
    expect(t.statements).to.have.length(2);
    expect(t.statements[0].statement).to.be.equal(query);
    expect(t.statements[0].parameters.props.name).to.be.equal('Foo Fighters');
    expect(t.statements[1].statement).to.be.equal(query);
    expect(t.statements[1].parameters.props.name).to.be.equal('Metallica');
    expect(t.status).to.be('new');
    expect(t.id).to.be(null);
    t.add(query, paramsWith('Tomte'), function(err, transaction) {
      var id;
      expect(err).to.be(null);
      expect(transaction.statements).to.have.length(3);
      expect(transaction.statements[2].statement).to.be.equal(query);
      expect(transaction.statements[2].parameters.props.name).to.be.equal('Tomte');
      expect(transaction.statements[0].status).not.to.be(null);
      expect(transaction.statements[1].status).not.to.be(null);
      expect(transaction.statements[2].status).not.to.be(null);
      expect(transaction.status).to.be('open');
      id = transaction.id;
      expect(id).to.be.above(0);
      return transaction.add(query, paramsWith('Pink Floyd'), function(err, transaction) {
        expect(err).to.be(null);
        expect(transaction.statements).to.have.length(4);
        expect(transaction.statements[3].parameters.props.name).to.be.equal('Pink Floyd');
        expect(transaction.statements[0].status).not.to.be(null);
        expect(transaction.statements[1].status).not.to.be(null);
        expect(transaction.statements[2].status).not.to.be(null);
        expect(transaction.statements[3].status).not.to.be(null);
        expect(transaction.status).to.be('open');
        expect(transaction.id).to.be.equal(id);
        return transaction.close(function(err, transaction) {
          expect(err).to.be(null);
          expect(transaction.id).to.be.equal(id);
          expect(transaction.status).to.be.equal('committed');
          return done();
        });
      });
    });
    return expect(t.status).to.be.equal('creating');
  });
  it('expect to handle many statements in a transaction asnyc', function(done) {
    var query;
    query = 'START n=node(*) MATCH (n)-[r]-() RETURN n LIMIT {l}';
    return Transaction.begin(query, {
      l: 1
    }).add(query, {
      l: 2
    }).commit(function(err, transaction) {
      expect(err).to.be(null);
      expect(transaction.untransmittedStatements().length).to.be(0);
      expect(transaction.status).to.be.equal('committed');
      return Transaction.create(query, {
        l: 1
      }).add(query, {
        l: 2
      }).close(function(err, transaction) {
        expect(err).to.be(null);
        expect(transaction.status).to.be.equal('committed');
        return done();
      });
    });
  });
  it('expect to get errors on wrong transactions', function(done) {
    var query;
    query = 'CREATE (n {props}) RETURN n AS node, id(n), as ID';
    return Transaction.commit(query, {
      props: {
        name: 'Philipp'
      }
    }, function(err, transaction) {
      expect(err).to.be(null);
      expect(transaction.status).to.be.equal('committed');
      expect(transaction.errors).to.have.length(1);
      return done();
    });
  });
  it('expect to get usable results', function(done) {
    var query;
    query = 'CREATE (n {props}) RETURN n AS node, id(n) AS ID';
    return Transaction.commit(query, {
      props: {
        name: 'Linda'
      }
    }, function(err, transaction) {
      expect(err).to.be(null);
      expect(transaction.results).to.have.length(1);
      expect(transaction.results[0].columns).to.have.length(2);
      expect(transaction.results[0].data[0][0].name).to.be.equal('Linda');
      expect(transaction.results[0].data[0][1]).to.be.above(0);
      expect(transaction.status).to.be.equal('committed');
      return Transaction.commit(Graph.create(query, {
        props: {
          name: 'Dave'
        }
      }), function(err, transaction) {
        expect(err).to.be(null);
        expect(transaction.results).to.have.length(1);
        expect(transaction.results[0].data[0][0].name).to.be.equal('Dave');
        expect(transaction.status).to.be.equal('committed');
        return done();
      });
    });
  });
  it('expect to execute rollbacks', function(done) {
    var query;
    query = 'CREATE (n {props}) RETURN n AS node, id(n) AS ID';
    return Transaction.open().add(query, {
      props: {
        name: 'Dave'
      }
    }).add(query, {
      props: {
        name: 'Nate'
      }
    }, function(err, transaction) {
      expect(err).to.be(null);
      expect(transaction.status).not.to.be.equal('finalized');
      expect(transaction.results[0].data[0][0].name).to.be.equal('Dave');
      expect(transaction.results[1].data[0][0].name).to.be.equal('Nate');
      return transaction.add(query, {
        props: {
          name: 'Taylor'
        }
      }, function(err, transaction) {
        var id;
        expect(err).to.be(null);
        expect(transaction.status).not.to.be.equal('finalized');
        id = transaction.results[0].data[0][1];
        expect(transaction.results).to.have.length(3);
        expect(transaction.results[0].data[0][0].name).to.be.equal('Dave');
        expect(transaction.results[1].data[0][0].name).to.be.equal('Nate');
        expect(transaction.results[2].data[0][0].name).to.be.equal('Taylor');
        expect(id).to.be.above(0);
        return client.get("/node/" + id, function(err, found) {
          expect(err).to.be(null);
          expect(found.id).to.be.equal(id);
          return transaction.rollback(function(err) {
            expect(err).to.be(null);
            return client.get("/node/" + id, function(err, found) {
              expect(err).to.be(null);
              expect(found).to.be(null);
              return done();
            });
          });
        });
      });
    });
  });
  return it('expect to rollback or commit all open transactions', function(done) {
    var query, t, zero;
    zero = Object.keys(Transaction.__open_transactions__);
    query = 'CREATE (n {props}) RETURN n AS node, id(n) AS ID';
    expect(Transaction.commitAll).to.be.equal(Transaction.closeAll);
    expect(Transaction.rollbackAll).to.be.equal(Transaction.deleteAll);
    expect(Transaction.rollbackAll).to.be.equal(Transaction.undoAll);
    t = Transaction.open().add(query, {
      props: {
        name: 'Dave'
      }
    }).add(query, {
      props: {
        name: 'Nate'
      }
    });
    expect(Object.keys(Transaction.__open_transactions__)).to.have.length(zero);
    return t.exec(function(err) {
      expect(err).to.be(null);
      expect(Object.keys(Transaction.__open_transactions__)).to.have.length(zero + 1);
      return t["delete"](function(err) {
        expect(err).to.be(null);
        expect(Object.keys(Transaction.__open_transactions__)).to.have.length(zero);
        return Transaction.open().add(query, {
          props: {
            name: 'Dave'
          }
        }).add(query, {
          props: {
            name: 'Nate'
          }
        }, function(err, t) {
          expect(err).to.be(null);
          expect(Object.keys(Transaction.__open_transactions__)).to.have.length(zero + 1);
          return t.close(function(err) {
            var uid1, uid2;
            expect(err).to.be(null);
            expect(Object.keys(Transaction.__open_transactions__)).to.have.length(zero);
            uid1 = generateUID();
            uid2 = generateUID();
            return Transaction.open().add(query, {
              props: {
                name: uid1
              }
            }, function(err, t1) {
              var nodeID1;
              expect(err).to.be(null);
              nodeID1 = t1.results[0].data[0][1];
              expect(nodeID1).to.be.above(0);
              return Transaction.open(query, {
                props: {
                  name: uid2
                }
              }, function(err, t2) {
                var nodeID2;
                expect(err).to.be(null);
                nodeID2 = t2.results[0].data[0][1];
                expect(nodeID2).to.be.above(0);
                expect(Object.keys(Transaction.__open_transactions__)).to.have.length(zero + 2);
                return Node.findById(nodeID1, function(err, found) {
                  expect(found.id).to.be.equal(nodeID1);
                  return Node.findById(nodeID2, function(err, found) {
                    expect(found.id).to.be.equal(nodeID2);
                    return Transaction.commitAll(function(err) {
                      expect(err).to.be(null);
                      expect(Object.keys(Transaction.__open_transactions__)).to.have.length(zero);
                      uid1 = generateUID();
                      uid2 = generateUID();
                      return Transaction.open(query, {
                        props: {
                          name: uid1
                        }
                      }, function(err, t1) {
                        nodeID1 = t1.results[0].data[0][1];
                        return Transaction.open(query, {
                          props: {
                            name: uid2
                          }
                        }, function(err, t2) {
                          nodeID2 = t2.results[0].data[0][1];
                          expect(Object.keys(Transaction.__open_transactions__)).to.have.length(zero + 2);
                          return Transaction.rollbackAll(function(err) {
                            expect(Object.keys(Transaction.__open_transactions__)).to.have.length(zero);
                            return Node.findById(nodeID1, function(err, found) {
                              expect(err).to.be(null);
                              expect(found).to.be(null);
                              return Node.findById(nodeID2, function(err, found) {
                                expect(err).to.be(null);
                                expect(found).to.be(null);
                                return done();
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
});
