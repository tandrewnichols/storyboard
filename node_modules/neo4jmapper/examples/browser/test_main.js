// Generated by CoffeeScript 1.6.3
var Graph, Join, Neo4j, Neo4jRestful, Node, Path, Relationship, SkipInBrowser, SkipInNode, SkipStreaming, Transaction, client, configForTest, expect, generateUID, helpers, neo4jmapper, version, _, _ref, _trim,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof root !== "undefined" && root !== null) {
  require('source-map-support').install();
  expect = require('expect.js');
  Join = require('join');
  _ = require('underscore');
  configForTest = require('./config');
  Neo4j = require("../" + configForTest.srcFolder + "/index.js");
  _ref = new Neo4j({
    url: configForTest.neo4jURL,
    onConnectionError: function(err) {
      throw err;
    }
  }), Graph = _ref.Graph, Node = _ref.Node, Relationship = _ref.Relationship, Path = _ref.Path, Transaction = _ref.Transaction, Neo4jRestful = _ref.Neo4jRestful, helpers = _ref.helpers, client = _ref.client;
} else {
  _ = window._;
  configForTest = _.extend({
    doLog: false,
    wipeDatabase: false,
    neo4jURL: 'http://yourserver:0000/'
  }, configForTest || {});
  Join = window.Join;
  neo4jmapper = new window.Neo4jMapper(configForTest.neo4jURL);
  Graph = neo4jmapper.Graph, Node = neo4jmapper.Node, Relationship = neo4jmapper.Relationship, Path = neo4jmapper.Path, Transaction = neo4jmapper.Transaction, Neo4jRestful = neo4jmapper.Neo4jRestful, helpers = neo4jmapper.helpers, client = neo4jmapper.client;
  Neo4j = Neo4jMapper;
}

if (configForTest.doLog) {
  client.constructor.prototype.log = Graph.prototype.log = configForTest.doLog;
}

version = client.version;

SkipInNode = function(a) {
  if (typeof window === "undefined" || window === null) {
    return null;
  } else {
    return a;
  }
};

SkipInBrowser = function(a) {
  if (typeof window !== "undefined" && window !== null) {
    return null;
  } else {
    return a;
  }
};

SkipStreaming = function(a) {
  return SkipInBrowser(a);
};

generateUID = function() {
  return helpers.md5(String(new Date().getTime()) + String(Math.round(Math.random() * 10000000)));
};

_trim = function(s) {
  return s.trim().replace(/\s+/g, ' ');
};

describe('Neo4jMapper', function() {
  before(function(done) {
    return client.checkAvailability(function(err, exact_version) {
      expect(err).to.be(null);
      expect(exact_version).to.be.a('string');
      expect(client.version >= 2).to.be(true);
      return Node.findAll().count(function(err, count) {
        if (count > 0) {
          return done();
        } else {
          return Node.create({
            name: 'dummy to avoid id=0 '
          }, function(err, node) {
            return Node.findById(0)["delete"](function() {
              return done();
            });
          });
        }
      });
    });
  });
  describe('generated cypher queries', function() {
    return it('expect to get a query on node + relationship instances', function(done) {
      return Node.create({
         name: 'whatever'
      }).setLabels(['Person']).save(function(err, node1) {
        var id;
        id = node1.id;
        expect(id).to.be.a('number');
        expect(_trim(node1.toQuery().toString())).to.match(/^START n = node\(\d+\) RETURN n, labels\(n\);/);
        return Graph.custom(node1, function(err, found) {
          expect(err).to.be(null);
          expect(found[0].id).to.be(node1.id);
          return Node.create({
             name: 'whatever'
          }, function(err, node2) {
            return node2.createRelationTo(node1, 'connected', function(err, rel) {
              expect(err).to.be(null);
              expect(_trim(rel.toQueryString())).to.match(/START r = relationship\(\d+\) RETURN r;/);
              return Relationship.create('know', {
                since: 'years'
              }, node1, node2, function(err, relationship) {
                expect(err).to.be(null);
                expect(_trim(relationship.toQueryString())).to.match(/START r = relationship\(\d+\) RETURN r;/);
                return done();
              });
            });
          });
        });
      });
    });
  });
  describe('client', function() {
    return it('expect to query directly via Neo4jRestful', function(done) {
      return Graph.request().query('START n=node(*) RETURN n AS Node LIMIT 1;', function(err, res) {
        expect(err).to.be(null);
        expect(res.columns).to.have.length(1);
        expect(res.data).to.have.length(1);
        return client.query('START n=node(*) RETURN n AS Node LIMIT 1;', function(err, res) {
          expect(err).to.be(null);
          expect(res.columns).to.have.length(1);
          expect(res.data).to.have.length(1);
          return done();
        });
      });
    });
  });
  describe('references', function() {
    return it('expect to work with the same object references', function() {
      expect(Node.Relationship).to.be.equal(Relationship);
      expect(Relationship.Node).to.be.equal(Node);
      expect(Neo4jRestful.Node).to.be.equal(Node);
      expect(Neo4jRestful.Path).to.be.equal(Path);
      expect(Neo4jRestful.Relationship).to.be.equal(Relationship);
      expect(client.Node).to.be.equal(Node);
      expect(client.Path).to.be.equal(Path);
      return expect(client.Relationship).to.be.equal(Relationship);
    });
  });
  describe('graph', function() {
    it('expect to create a graph object, with all variants of arguments', function(done) {
      var join, neo4j;
      join = Join.create();
      neo4j = new Neo4j({
        url: configForTest.neo4jURL
      });
      neo4j.client.checkAvailability(join.add());
      neo4j = new Neo4j(configForTest.neo4jURL);
      neo4j.client.checkAvailability(join.add());
      return join.when(function() {
        var arg, _i, _len, _ref1;
        _ref1 = Array.prototype.slice.apply(arguments);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          arg = _ref1[_i];
          expect(arg[0]).to.be(null);
          expect(arg[1]).to.be.a('string');
        }
        return done();
      });
    });
    it("expect " + (configForTest.wipeDatabase ? "" : "not ") + "to remove all nodes and relationships from the database", function(done) {
      var graph;
      if (!configForTest.wipeDatabase) {
        return done();
      }
      graph = new Graph();
      return graph.wipeDatabase(function(err, res) {
        expect(err).to.be(null);
        return done();
      });
    });
    it('expect to get information about the server', function(done) {
      var graph;
      graph = new Graph();
      return graph.about(function(err, data) {
        expect(err).to.be(null);
        expect(graph.info).to.be.an('object');
        return done();
      });
    });
    it('expect to get a neo4j version value', function(done) {
      var graph;
      graph = new Graph();
      return graph.about(function() {
        expect(client.version).to.be.a('number');
        expect(client.version >= 2).to.be(true);
        expect(client.exact_version).to.be.a('string');
        return done();
      });
    });
    it('expect to count all nodes in database', function(done) {
      var graph;
      graph = new Graph();
      return graph.countNodes(function(err, count) {
        expect(err).to.be(null);
        expect(count).to.be.a('number');
        return done();
      });
    });
    it('expect to count all relationships in database', function(done) {
      var graph;
      graph = new Graph();
      return graph.countRelationships(function(err, count) {
        expect(err).to.be(null);
        expect(count).to.be.a('number');
        return done();
      });
    });
    it('expect to count all nodes + relationships in database', function(done) {
      var count, graph;
      graph = new Graph();
      count = 0;
      return graph.countNodes(function(err, countNodes) {
        count += countNodes;
        return graph.countRelationships(function(err, countRelationships) {
          count += countRelationships;
          return graph.countAll(function(err, count) {
            expect(err).to.be(null);
            expect(count).to.be.equal(count);
            return done();
          });
        });
      });
    });
    it('expect to measure time of request and response', function(done) {
      var graph;
      graph = new Graph();
      return graph.countAll(function(err, count) {
        expect(err).to.be(null);
        expect(graph.neo4jrestful.responseTime()).to.be.above(1);
        expect(graph.neo4jrestful.responseTimeAsString()).to.match(/^\d+(\.\d+)*\[s\]$/);
        return done();
      });
    });
    it('expect to query via Graph, with and without loading', function(done) {
      return Node.registerModel('Person', function(err, Person) {
        var name;
        name = generateUID();
        return new Person({
          name: name
        }).save(function(err, alice) {
          return new Person({
            name: 'otherPerson'
          }).save(function(err, bob) {
            return alice.createRelationTo(bob, 'KNOWS', function(err, relationship) {
              return Graph.start('n = node(*)').match('(n:Person)-[r]-()').where({
                'n.name': name
              })["return"]('n AS Node, r AS Relationship, labels(n)').enableLoading('node|relationship').limit(1).exec(function(err, result, debug) {
                var person;
                expect(err).to.be(null);
                expect(result).to.have.length(2);
                person = result[0];
                relationship = result[1];
                expect(person.label).to.be.equal('Person');
                expect(relationship.from.label).to.be.equal('Person');
                return Graph.start('n = node(*)').match('(n:Person)-[r]-()').where({
                  'n.name': name
                })["return"]('n AS Node, r AS Relationship').limit(1).disableProcessing().exec(function(err, result, debug) {
                  expect(err).to.be(null);
                  expect(result.data).to.have.length(1);
                  expect(result.data[0]).to.have.length(2);
                  person = result.data[0][0];
                  relationship = result.data[0][1];
                  expect(person.label).to.be(null);
                  expect(relationship.from.label).to.be(void 0);
                  return done();
                });
              });
            });
          });
        });
      });
    });
    it('expect to make many different concurrent queries', function(done) {
      var i, id, todo, _i, _results;
      todo = 40;
      _results = [];
      for (i = _i = 0; 0 <= todo ? _i < todo : _i > todo; i = 0 <= todo ? ++_i : --_i) {
        id = generateUID();
        _results.push((function(id) {
          return Node.create({
            name: id
          }, function(err, node) {
            expect(err).to.be(null);
            expect(node.data.name).to.be.equal(id);
            return Graph.start().query('START n=node(' + node.id + ') RETURN n', function(err, found) {
              expect(err).to.be(null);
              expect(found[0].data.name).to.be.equal(id);
              todo--;
              if (todo === 0) {
                return done();
              }
            });
          });
        })(id));
      }
      return _results;
    });
    it('expect to request many concurrent queries on different databases', function(done) {
      var databases, todo;
      todo = 40;
      databases = [configForTest.neo4jURL];
      if (configForTest.neo4jURL2) {
        databases.push(configForTest.neo4jURL2);
      }
      return databases.forEach(function(url) {
        var _Graph_, _Neo4j_, _Node_, _client_;
        _Neo4j_ = new Neo4j(url);
        _Node_ = _Neo4j_.Node;
        _Graph_ = _Neo4j_.Graph;
        _client_ = _Neo4j_.client;
        return (function(_Node_, _Graph_, _client_) {
          var _i, _results;
          return (function() {
            _results = [];
            for (var _i = 0; 0 <= todo ? _i < todo : _i > todo; 0 <= todo ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this).forEach(function(i) {
            var id;
            id = generateUID();
            return _Node_.create({
              name: id
            }, function(err, node) {
              expect(err).to.be(null);
              expect(node.data.name).to.be.equal(id);
              return _Graph_.start().query('START n=node(' + node.id + ') RETURN n', function(err, found, debug) {
                expect(err).to.be(null);
                expect(found[0].data.name).to.be.equal(id);
                todo--;
                if (todo === 0) {
                  return done();
                }
              });
            });
          });
        })(_Node_, _Graph_, _client_);
      });
    });
    it('expect to query via Graph with parameters', function(done) {
      var Person, name;
      Person = Node.registerModel('Person');
      name = generateUID();
      return new Person({
        name: name
      }).save(function(err, alice) {
        return new Person({
          name: 'otherPerson'
        }).save(function(err, bob) {
          return alice.createRelationTo(bob, 'KNOWS', function(err, relationship) {
            var graph;
            return graph = Graph.start('n = node(*)').where({
              'n.name': name
            })["return"]('n AS Node').limit(1).exec(function(err, found) {
              expect(err).to.be(null);
              expect(found.data.name).to.be.equal(name);
              return done();
            });
          });
        });
      });
    });
    it('expect to get many columns of graph queries', function(done) {
      var Person, name;
      Person = Node.registerModel('Person');
      name = generateUID();
      return new Person({
        name: name
      }).save(function(err, alice) {
        return new Person({
          name: name
        }).save(function(err, bob) {
          return alice.createRelationTo(bob, 'KNOWS', function(err, relationship) {
            return Graph.start('n = node(*)').match('(n:Person)-[r]-()').where({
              'n.name': name
            })["return"]('n, r').limit(2).exec(function(err, found) {
              expect(err).to.be(null);
              expect(found).to.have.length(2);
              expect(found[0]).to.have.length(2);
              return done();
            });
          });
        });
      });
    });
    it('expect to stream graph query results', SkipStreaming(function(done) {
      var i;
      i = 0;
      return Graph.start('n=node(*)')["return"]('n').limit(1).stream(function(node, context) {
        if (node) {
          expect(context._columns_.constructor).to.be.equal(Array);
          return i++;
        } else {
          expect(i).to.be(1);
          return done();
        }
      });
    }));
    it('expect to stream graph query with parameters', SkipStreaming(function(done) {
      var i;
      i = 0;
      return Node.create({
        name: generateUID()
      }, function(err, n) {
        return Graph.start('n=node({id})', {
          id: n.id
        })["return"]('n').limit(1).stream(function(node, context, debug) {
          if (node) {
            expect(context._columns_.constructor).to.be.equal(Array);
            expect(node.id).to.be.equal(n.id);
            return i++;
          } else {
            expect(i).to.be(1);
            return done();
          }
        });
      });
    }));
    it('expect to have response and debug object on stream cb', SkipStreaming(function(done) {
      var i;
      i = 0;
      return Node.create({
        name: generateUID()
      }, function(err, n) {
        return Graph.start('n=node({id})', {
          id: n.id
        })["return"]('n').limit(1).stream(function(node, context, debug) {
          expect(context.constructor).to.be.equal(Graph);
          expect(Object.keys(context._response_).length).to.be.above(0);
          expect(Object.keys(debug).length).to.be.above(0);
          if (node) {
            return i++;
          } else {
            expect(i).to.be(1);
            return done();
          }
        });
      });
    }));
    it('expect to stream native graph query results', SkipStreaming(function(done) {
      var i;
      i = 0;
      return Graph.stream('START n=node(*) RETURN n LIMIT 1;', function(node) {
        if (node) {
          return i++;
        } else {
          expect(i).to.be(1);
          return done();
        }
      });
    }));
    return it('expect to query graph native and not native (not native by default)', function(done) {
      var name;
      name = generateUID();
      return new Node({
        name: name
      }).setLabel('Person').save(function(err, person) {
        return Graph.start('n=node(*)').where({
          'n.name': name
        })["return"]('n AS Node').limit(1).exec(function(err, found) {
          var id;
          expect(err).to.be(null);
          expect(found.label).to.be.equal('Person');
          id = found.id;
          expect(id).to.be.a('number');
          return Graph.disableProcessing().start('n=node(*)').where({
            'n.name': name
          })["return"]('n AS Node').limit(1).exec(function(err, result, debug) {
            expect(err).to.be(null);
            expect(result.columns).to.have.length(1);
            expect(result.data[0]).to.have.length(1);
            expect(result.data[0][0].id).to.be.equal(id);
            return done();
          });
        });
      });
    });
  });
  describe('stream', function() {
    it('expect to make a stream request on nodes and models', SkipStreaming(function(done) {
      var Person, _ref1;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      Node.registerModel(Person);
      return new Person({
        name: 'A'
      }).save(function() {
        return new Person({
          name: 'B'
        }).save(function() {
          return Person.findAll().count(function(err, count) {
            var iterationsCount;
            expect(err).to.be(null);
            expect(count).to.be.above(0);
            iterationsCount = 0;
            if (count > 10) {
              count = 10;
            }
            return Person.findAll().limit(count - 1).each(function(data, res, debug) {
              var iteration;
              if (data) {
                expect(data._constructor_name_).to.be.equal('Person');
                expect(data._response_.self).to.be.a('string');
                expect(data.labels).to.be.eql(['Person']);
                expect(data.label).to.be.equal('Person');
                return iterationsCount++;
              } else {
                expect(iterationsCount).to.be.equal(count - 1);
                iteration = 0;
                return Node.findOne().each(function(node) {
                  iteration++;
                  if (node) {
                    expect(node.label).to.be(null);
                    return expect(node.labels).to.be.eql([]);
                  } else {
                    expect(iteration).to.be.equal(2);
                    return done();
                  }
                });
              }
            });
          });
        });
      });
    }));
    return it('expect to make a stream request on the graph', SkipStreaming(function(done) {
      return Node.findAll().count(function(err, count) {
        var iterationsCount;
        expect(count).to.be.above(1);
        iterationsCount = 0;
        if (count > 10) {
          count = 10;
        }
        return Graph.stream("START n=node(*) RETURN n, labels(n) LIMIT " + count + ";", function(row) {
          if (!row) {
            expect(count).to.be.equal(count);
            return done();
          } else {
            expect(row[0].id).to.be.a('number');
            expect(row[1].constructor).to.be.equal(Array);
            return count++;
          }
        });
      });
    }));
  });
  describe('node', function() {
    it('expect to apply inheritance on models', function(done) {
      return Node.registerModel('Person', {
        fields: {
          defaults: {
            name: '',
            email: 'unknown',
            income: 50000,
            job: 'Laborer'
          },
          indexes: {
            job: true
          }
        }
      }, function(err, Person) {
        var person;
        expect(err).to.be(null);
        Person.prototype.fullname = function() {
          var s, _ref1, _ref2;
          s = '';
          if ((_ref1 = this.data) != null ? _ref1.name : void 0) {
            s += this.data.name;
          }
          if ((_ref2 = this.data) != null ? _ref2.surname : void 0) {
            s += ' ' + this.data.surname;
          }
          return "[" + (s.trim()) + "]";
        };
        person = new Person();
        expect(person).to.be.an('object');
        expect(person.label).to.be('Person');
        expect(person._constructor_name_).to.be('Person');
        expect(person.fields.defaults).to.be.eql({
          name: '',
          email: 'unknown',
          income: 50000,
          job: 'Laborer'
        });
        expect(person.fullname()).to.be.equal('[]');
        return Person.registerModel('Director', {
          fields: {
            defaults: {
              income: 80000,
              job: 'Director'
            },
            indexes: {
              income: true
            }
          }
        }, function(err, Director) {
          var director;
          expect(err).to.be(null);
          director = new Director();
          expect(director.label).to.be.equal('Director');
          expect(director._constructor_name_).to.be.equal('Director');
          expect(director.fields.defaults).to.be.eql({
            name: '',
            email: 'unknown',
            income: 80000,
            job: 'Director'
          });
          expect(director.fields.indexes).to.be.eql({
            job: true,
            income: true
          });
          expect(Director.prototype.labels).to.be.eql(['Director', 'Person']);
          expect(director).to.be.an('object');
          expect(director.id).to.be(null);
          expect(director.fullname()).to.be.equal('[]');
          return Person.registerModel('Actor', {
            fields: {
              defaults: {
                job: 'Actor'
              }
            }
          }, function(err, Actor, debug) {
            var actor;
            expect(Actor.prototype._constructor_name_).to.be.equal('Actor');
            expect(Actor.prototype.label).to.be.equal('Actor');
            expect(Actor.prototype.labels).to.be.eql(['Actor', 'Person']);
            expect(err).to.be(null);
            actor = new Actor();
            expect(actor.labels).to.be.eql(['Actor', 'Person']);
            expect(actor.label).to.be('Actor');
            expect(actor._constructor_name_).to.be('Actor');
            expect(actor.fields.defaults).to.be.eql({
              name: '',
              email: 'unknown',
              income: 50000,
              job: 'Actor'
            });
            return Actor.create({
              name: 'Jeff',
              surname: 'Bridges'
            }, function(err, jeff) {
              expect(jeff.fullname()).to.be.equal('[Jeff Bridges]');
              expect(jeff.data.income).to.be.equal(50000);
              expect(jeff.data.job).to.be.equal('Actor');
              expect(jeff.data.email).to.be.equal('unknown');
              expect(jeff.label).to.be.equal('Actor');
              expect(jeff._constructor_name_).to.be.equal('Actor');
              return Actor.findById(jeff.id, function(err, jeff, debug) {
                expect(jeff.fullname()).to.be.equal('[Jeff Bridges]');
                expect(jeff.data.income).to.be.equal(50000);
                expect(jeff.data.job).to.be.equal('Actor');
                expect(jeff.data.email).to.be.equal('unknown');
                expect(jeff.label).to.be.equal('Actor');
                expect(jeff._constructor_name_).to.be.equal('Actor');
                return done();
              });
            });
          });
        });
      });
    });
    it('inheritance on coffescript class-objects', function(done) {
      var Actor, Director, Extra, Person, director, _ref1, _ref2, _ref3, _ref4;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      Extra = (function(_super) {
        __extends(Extra, _super);

        function Extra() {
          _ref2 = Extra.__super__.constructor.apply(this, arguments);
          return _ref2;
        }

        return Extra;

      })(Person);
      Actor = (function(_super) {
        __extends(Actor, _super);

        function Actor() {
          _ref3 = Actor.__super__.constructor.apply(this, arguments);
          return _ref3;
        }

        return Actor;

      })(Extra);
      Director = (function(_super) {
        __extends(Director, _super);

        function Director() {
          _ref4 = Director.__super__.constructor.apply(this, arguments);
          return _ref4;
        }

        return Director;

      })(Actor);
      Person = Node.registerModel(Person);
      Actor = Node.registerModel(Actor);
      Director = Node.registerModel(Director);
      director = new Director;
      expect(director.labels).to.have.length(4);
      expect(director.labels[0]).to.be.equal('Director');
      expect(director.labels[1]).to.be.equal('Actor');
      expect(director.labels[2]).to.be.equal('Extra');
      expect(director.labels[3]).to.be.equal('Person');
      expect(director.label).to.be.equal('Director');
      expect(_.keys(director.fields.indexes)).to.have.length(0);
      expect(_.keys(director.fields.unique)).to.have.length(0);
      expect(_.keys(director.fields.defaults)).to.have.length(0);
      return done();
    });
    it('inheritance on models', function(done) {
      var Actor, Director, Extra, Person, director, uid;
      Person = Node.registerModel('Person');
      Extra = Person.registerModel('Extra');
      Actor = Extra.registerModel('Actor');
      Director = Actor.registerModel('Director');
      director = new Director;
      expect(director.labels).to.have.length(4);
      expect(director.labels[0]).to.be.equal('Director');
      expect(director.labels[1]).to.be.equal('Actor');
      expect(director.labels[2]).to.be.equal('Extra');
      expect(director.labels[3]).to.be.equal('Person');
      expect(director.label).to.be.equal('Director');
      uid = new Date;
      director.data = {
        name: 'Roman Polanski',
        uid: uid
      };
      return director.save(function(err, polanski) {
        expect(polanski.labels).to.have.length(4);
        expect(director.labels).to.have.length(4);
        expect(director.label).to.be.equal('Director');
        expect(polanski.label).to.be.equal('Director');
        return done();
      });
    });
    it('expect to create a node', function(done) {
      var node;
      node = new Node({
        title: generateUID()
      });
      return node.save(function(err, storedNode) {
        var id;
        id = node.id;
        expect(err).to.be(null);
        expect(storedNode.data.title).to.be(node.data.title);
        expect(storedNode.id).to.be.above(0);
        return Node.findById(id, function(err, found) {
          expect(found).to.be.an('object');
          expect(found.id).to.be.equal(id);
          expect(found.data.title).to.be.equal(node.data.title);
          return done();
        });
      });
    });
    it('expect to remove a node', function(done) {
      return Node.create({
        name: 'Roman Polanski'
      }, function(err, node) {
        expect(node.id).to.be.a('number');
        return node.remove(function(err, res, debug) {
          expect(err).to.be(null);
          return done();
        });
      });
    });
    it('expect to use parameters for queries by default and expect to add parameters to cypher query', function() {
      var i, node, shouldBe, value, _i, _len, _ref1, _results;
      node = new Node({
        title: generateUID()
      });
      expect(node.cypher.useParameters).to.be(true);
      expect(node.cypher.parameters).to.be(null);
      node._addParametersToCypher(['a', 'b']);
      node._addParametersToCypher(['c', 'd']);
      shouldBe = ['a', 'b', 'c', 'd'];
      _ref1 = node.cypher.parameters;
      _results = [];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        value = _ref1[i];
        _results.push(expect(value).to.be.equal(shouldBe[i]));
      }
      return _results;
    });
    it('expect to find one specific node by id', function(done) {
      var Person, node;
      Person = Node.registerModel('Person');
      node = new Person({
        title: generateUID()
      });
      return node.save(function(err, a, debug) {
        return Node.findById(node.id, function(err, found) {
          expect(err).to.be(null);
          expect(found.data.title).to.be.equal(node.data.title);
          expect(found.id).to.be.equal(node.id);
          expect(found.label).to.be.equal('Person');
          expect(found.labels).to.be.eql(['Person']);
          expect(found._constructor_name_).to.be.equal('Person');
          return node.remove(function() {
            return done();
          });
        });
      });
    });
    it('expect to get null instead of an error if node by id is not found', function(done) {
      return Node.findById(new Date().getTime(), function(err, found) {
        expect(err).to.be(null);
        expect(found).to.be(null);
        return done();
      });
    });
    it('expect to find a node by id matching the corresponding label', function(done) {
      var Department, Person;
      Person = Node.registerModel('Person');
      Department = Node.registerModel('Department');
      return Department.create({
        name: 'R+D'
      }, function(err, department) {
        expect(err).to.be(null);
        return Person.create({
          name: 'Lisa'
        }, function(err, lisa) {
          expect(err).to.be(null);
          return Department.findById(lisa.id, function(err, found) {
            expect(err).to.be(null);
            expect(found).to.be(null);
            return done();
          });
        });
      });
    });
    it('expect to find one specific node by key/value', function(done) {
      var node;
      node = new Node({
        title: generateUID()
      });
      return node.save(function() {
        return Node.findOneByKeyValue('title', node.data.title, function(err, found) {
          expect(found.data.title).to.be.equal(node.data.title);
          expect(found.id).to.be.equal(node.id);
          return node.remove(function() {
            return done();
          });
        });
      });
    });
    it('expect to get null as result if one specific node is not found', function(done) {
      return Node.findOne({
        SomeKey: new Date().getTime()
      }, function(err, found) {
        expect(err).to.be(null);
        expect(found).to.be(null);
        return done();
      });
    });
    it('expect to find many nodes with different labels', function(done) {
      var groupid;
      Node.unregisterModel('Person');
      Node.unregisterModel('Developer');
      groupid = new Date().getTime();
      return new Node({
        name: 'Alice',
        group_id: groupid
      }).addLabel('Person').save(function(err, alice) {
        expect(err).to.be(null);
        expect(alice.label).to.be('Person');
        expect(alice.labels[0]).to.be('Person');
        return new Node({
          name: 'Bob',
          group_id: groupid
        }).addLabel('Developer').save(function(err, bob) {
          expect(err).to.be(null);
          expect(bob.label).to.be('Developer');
          expect(bob.labels[0]).to.be('Developer');
          return Node.find({
            group_id: groupid
          }, function(err, nodes) {
            var Developer, _ref1;
            expect(err).to.be(null);
            expect(nodes).to.have.length(2);
            expect(nodes[0]._constructor_name_).to.be.equal('Node');
            expect(nodes[1]._constructor_name_).to.be.equal('Node');
            Developer = (function(_super) {
              __extends(Developer, _super);

              function Developer() {
                _ref1 = Developer.__super__.constructor.apply(this, arguments);
                return _ref1;
              }

              Developer.prototype.fields = {
                indexes: {
                  email: true
                }
              };

              return Developer;

            })(Node);
            return Node.registerModel(Developer, function(err, Developer) {
              return Developer.dropEntireIndex(function(err) {
                var _ref2;
                expect(err).to.be(null);
                Developer = (function(_super) {
                  __extends(Developer, _super);

                  function Developer() {
                    _ref2 = Developer.__super__.constructor.apply(this, arguments);
                    return _ref2;
                  }

                  Developer.prototype.fields = {
                    indexes: {
                      email: true
                    }
                  };

                  return Developer;

                })(Node);
                return Node.registerModel(Developer, function(err, Developer) {
                  return Developer.find({
                    group_id: groupid
                  }, function(err, nodes) {
                    expect(err).to.be(null);
                    expect(nodes).to.have.length(1);
                    expect(nodes[0].data.name).to.be.equal('Bob');
                    return Developer.getIndex(function(err, found, debug) {
                      expect(err).to.be(null);
                      expect(found).to.have.length(1);
                      expect(found[0]).to.be.equal('email');
                      return done();
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    it('expect to remove a node', function(done) {
      var node;
      node = new Node({
        title: 'test'
      });
      return node.save(function() {
        return new Graph().countNodes(function(err, countNodesBefore) {
          return node.remove(function(err) {
            return new Graph().countNodes(function(err, countNodesAfter) {
              var id;
              id = node.id;
              expect(err).to.be(null);
              expect(countNodesBefore - 1).to.be(countNodesAfter);
              return done();
            });
          });
        });
      });
    });
    it('expect to query customized via cypher', function(done) {
      var graph, query;
      query = "START nodes=node(*)\nRETURN nodes LIMIT 10;";
      return graph = Graph.start().query(query, function(err, results) {
        expect(err).to.be(null);
        expect(graph._columns_.length).to.be.a('number');
        expect(results.length).to.be.a('number');
        return done();
      });
    });
    it('expect to query customized via cypher natively', function(done) {
      var graph, query;
      query = "START nodes=node(*)\nRETURN nodes LIMIT 10;";
      return graph = Graph.query(query, function(err, results) {
        expect(err).to.be(null);
        expect(graph._columns_.length).to.be.a('number');
        expect(results.columns.length).to.be.equal(graph._columns_.length);
        expect(results.data.length).to.be.a('number');
        return Graph.start().disableLoading().disableSorting().query(query, function() {
          expect(err).to.be(null);
          expect(results.columns.length).to.be.equal(graph._columns_.length);
          expect(results.data.length).to.be.a('number');
          return done();
        });
      });
    });
    it('expect to get suitable errors on wrong customized cypher queries', function(done) {
      return Graph.query("START nodes=node(*)\nRETURN nodes LIMITS 10;", function(err, results) {
        expect(err.message).to.be.a('string');
        expect(err.stacktrace.length).to.be.a('number');
        return done();
      });
    });
    it('expect to get suitable error on wrong mapper cypher queries', function(done) {
      return Node.findOne().where("thisWillProduceAnError BECAUSE 'it\'s not a valid cypher query at all'", function(err) {
        expect(err).to.be.an('object');
        expect(/^[A-Z]+[a-z]+/.test(err.message)).to.be(true);
        expect(/SyntaxException/i.test(err.exception)).to.be(true);
        return done();
      });
    });
    it('expect to get all nodes', function(done) {
      var n;
      n = new Node();
      n = n.findAll().limit(100).where("HAS (n.collection) AND n.collection = 'users'");
      return n.exec(function(err, data) {
        n = new Node();
        n = n.findAll().limit(10).where("n.collection = 'users'");
        return n.exec(function(err, found) {
          n = n.findAll().limit(10).where([
            {
              $and: [
                {
                  'HAS (n.collection)': 'HAS (n.collection)'
                }, {
                  'n.collection': /^users$/i
                }
              ]
            }
          ]);
          return n.exec(function() {
            return done();
          });
        });
      });
    });
    it('expect to get null if node is not found', function(done) {
      return Node.findById(Number('9' + Math.floor(Math.random() * 1000000000)), function(err, found) {
        expect(err).to.be(null);
        expect(found).to.be(null);
        return Node.findOneByKeyValue({
           key: new Date().getTime()
        }, function(err, found) {
          expect(err).to.be(null);
          expect(found).to.be(null);
          return done();
        });
      });
    });
    it('expect to process data between javascript and neo4j as good as possible', function(done) {
      var n;
      n = new Node();
      n.data = {
        title: 'Hello World',
        whatever: {
          nested: 'pinguin'
        },
        numberArray: [1, 2, 3],
        stringArray: ['a', 'b', 'c'],
        complexObject: [
          {
            a: true
          }
        ],
        other: {
          nested: ['A']
        }
      };
      return n.save(function(err, node) {
        var id;
        id = node.id;
        expect(node.data.title).to.be.equal(n.data.title);
        expect(node.data.numberArray.constructor).to.be.equal(Array);
        expect(node.data.complexObject[0].a).to.be(true);
        expect(node.data.other.nested).to.have.length(1);
        return done();
      });
    });
    it('expect to update a node', function(done) {
      return new Node({
        title: 'Hello World!'
      }).save(function(err, node) {
        var id;
        expect(node.data.title).to.be.equal('Hello World!');
        id = node.id;
        return Node.findById(id, function(err, found) {
          found.data.title = 'How are you?';
          return found.save(function(err, savedNode) {
            expect(savedNode.data.title).to.be.equal('How are you?');
            expect(err).to.be(null);
            return Node.findById(id, function(err, foundAgain) {
              expect(foundAgain.data.title).to.be(found.data.title);
              return foundAgain.removeIncludingRelations(function(err) {
                expect(err).to.be(null);
                return node.remove(function() {
                  return done();
                });
              });
            });
          });
        });
      });
    });
    it('expect to update a node with null values', function(done) {
      return Node.create({
        name: 'Alice',
        year: 1982,
        gender: 'male',
        nullValue: null,
        undefinedValue: void 0
      }, function(err, alice) {
        expect(err).to.be(null);
        expect(alice.id).to.be.above(-1);
        expect(alice.data).to.be.eql({
          name: 'Alice',
          year: 1982,
          gender: 'male'
        });
        return done();
      });
    });
    it('expect to update data of a node by id', function(done) {
      return new Node({
        name: 'Dave Grohl',
        origin: {
           country: 'USA',
          state: ''
        }
      }).save(function(err, dave) {
        var id;
        expect(err).to.be(null);
        expect(dave.data.name).to.be.equal('Dave Grohl');
        expect(dave.data.origin.state).to.be.equal('');
        expect(dave.data.origin.country).to.be.equal('USA');
        id = dave.id;
        expect(id).to.be.above(0);
        return Node.findById(id).update({
          origin: {
            state: 'Ohio'
          }
        }, function(err, daveSaved) {
          expect(err).to.be(null);
          expect(daveSaved.data.name).to.be.equal('Dave Grohl');
          expect(daveSaved.data.origin.state).to.be.equal('Ohio');
          expect(daveSaved.data.origin.country).to.be.equal('USA');
          expect(daveSaved.id).to.be(id);
          return daveSaved.update({
            'origin.country': 'United States of America'
          }, function(err, daveSaved) {
            expect(err).to.be(null);
            expect(daveSaved.data.name).to.be.equal('Dave Grohl');
            expect(daveSaved.data.origin.state).to.be.equal('Ohio');
            expect(daveSaved.data.origin.country).to.be.equal('United States of America');
            expect(daveSaved.id).to.be(id);
            return Node.findById(1234567).update({
               name: 'Node that doesnt exists'
            }, function(err, found) {
              expect(err.exception).to.be.equal('EntityNotFoundException');
              return done();
            });
          });
        });
      });
    });
    it('expect to execute onBeforeSave hook if defined', function(done) {
      var n;
      n = new Node();
      n.called_on_before_save = false;
      n.onBeforeSave = function(self, next) {
        n.called_on_before_save = true;
        return next();
      };
      return n.save(function(err) {
        expect(err).to.be(null);
        expect(n.called_on_before_save).to.be(true);
        return n.remove(function() {
          return done();
        });
      });
    });
    return it('expect to execute onBeforeRemove hook if defined', function(done) {
      var n;
      n = new Node();
      n.called_on_before_remove = false;
      n.onBeforeRemove = function(next) {
        n.called_on_before_remove = true;
        return next();
      };
      return n.save(function(err) {
        expect(n.called_on_before_remove).to.be(false);
        return n.remove(function(err) {
          expect(err).to.be(null);
          expect(n.called_on_before_remove).to.be(true);
          return done();
        });
      });
    });
  });
  describe('classes and models', function() {
    it('expect to register and unregister models for nodes', function() {
      var Movie, Person, movie, _ref1;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      Node.registerModel(Person);
      expect(Node.registered_models()['Person'].constructor).to.be(Person.constructor);
      Node.unregisterModel(Person);
      expect(Node.registered_models()['Person']).to.be(void 0);
      Node.registerModel(Person);
      Node.unregisterModel('Person');
      expect(Node.registered_models()['Person']).to.be(void 0);
      Movie = Node.registerModel('Movie');
      movie = new Movie();
      expect(movie.label).to.be.equal('Movie');
      return expect(movie._constructor_name_).to.be.equal('Movie');
    });
    it('expect to find corresponding node to each model', function(done) {
      var Movie, _ref1;
      Movie = (function(_super) {
        __extends(Movie, _super);

        function Movie() {
          _ref1 = Movie.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Movie;

      })(Node);
      Node.registerModel(Movie);
      return Movie.findAll().count(function(err, countBefore) {
        var lebowski;
        expect(err).to.be(null);
        expect(countBefore).to.be.a('number');
        lebowski = new Movie({
          title: 'The Big Lebowski'
        });
        return lebowski.save(function(err, lebowski) {
          expect(_.keys(lebowski.data)).to.have.length(1);
          expect(err).to.be(null);
          return Movie.findAll().count(function(err, countNow) {
            expect(countBefore + 1).to.be(countNow);
            return lebowski.remove(function() {
              return done();
            });
          });
        });
      });
    });
    it('expect to convert to specific models', function(done) {
      var Director, _ref1;
      Director = (function(_super) {
        __extends(Director, _super);

        function Director() {
          _ref1 = Director.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Director;

      })(Node);
      Node.registerModel(Director);
      return new Director({
        name: 'Robert Zemeckis'
      }).save(function(err, robert) {
        expect(err).to.be(null);
        expect(robert._constructor_name_).to.be('Director');
        expect(robert.label).to.be('Director');
        return Node.findById(robert.id, function(err, found) {
          expect(found.label).to.be.equal('Director');
          found = found.convertToModel(Director);
          expect(found._constructor_name_).to.be.equal('Director');
          return done();
        });
      });
    });
    it('expect to create, get and drop index(es)', function(done) {
      var labelName;
      labelName = "Person" + (new Date().getTime());
      return Node.registerModel(labelName, {
        fields: {
          indexes: {
            name: true
          }
        }
      }, function(err, Person) {
        expect(err).to.be(null);
        return Person.getIndex(function(err, res) {
          expect(err).to.be(null);
          expect(res).to.be.eql(['name']);
          return Person.dropEntireIndex(function(err) {
            expect(err).to.be(null);
            return Person.getIndex(function(err, res) {
              expect(err).to.be(null);
              expect(res).to.be.eql([]);
              return Person.ensureIndex(function(err, res) {
                expect(err).to.be(null);
                return Person.getIndex(function(err, res) {
                  expect(err).to.be(null);
                  expect(res).to.be.eql(['name']);
                  return Node.registerModel(labelName, {
                    fields: {
                      indexes: {
                        email: true
                      }
                    }
                  }, function(err, Director) {
                    return Director.getIndex(function(err, res) {
                      expect(err).to.be(null);
                      res = _.uniq(res);
                      expect(res).to.have.length(2);
                      expect(res[0]).to.match(/^(email|name)$/);
                      expect(res[1]).to.match(/^(email|name)$/);
                      return done();
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    it('expect to autoindex models', function(done) {
      var labelName;
      labelName = "Movie" + (new Date().getTime());
      return Node.registerModel(labelName, {
        fields: {
          indexes: {
            uid: true,
            nested: {
              id: true
            }
          }
        }
      }, function(err, Movie) {
        var deathAndMaiden, uid;
        deathAndMaiden = new Movie({
          title: 'Death and the Maiden'
        });
        deathAndMaiden.data.uid = uid = generateUID();
        return deathAndMaiden.save(function(err) {
          expect(err).to.be(null);
          return Movie.findAll().where({
            uid: uid
          }, function(err, found) {
            expect(err).to.be(null);
            expect(found).to.have.length(1);
            expect(found[0].data.uid).to.be.equal(uid);
            return deathAndMaiden.remove(function() {
              return done();
            });
          });
        });
      });
    });
    it('expect to have unique values', function(done) {
      var labelName;
      labelName = "Label" + (new Date().getTime());
      return Node.registerModel(labelName, {
        fields: {
          unique: {
            uid: true
          },
          defaults: {
            uid: function() {
              return new Date().getTime();
            }
          }
        }
      }, function(err, Model) {
        expect(err).to.be(null);
        return new Model().save(function(err, record) {
          var uid;
          expect(err).to.be(null);
          uid = record.data.uid;
          expect(record.data.uid).to.be.a('number');
          return new Model({
            uid: uid
          }).save(function(err) {
            expect(err.message).to.be.a('string');
            return Model.find({
              uid: uid
            }, function(err, found) {
              expect(found.length).to.be(1);
              return done();
            });
          });
        });
      });
    });
    return it('expect to set default values on models', function(done) {
      var labelName;
      labelName = "Movie" + (new Date().getTime());
      return Node.registerModel(labelName, {
        fields: {
          defaults: {
            uid: function() {
              return new Date().getTime();
            },
            is_movie: true,
            director: 'Roman Polanski'
          }
        }
      }, function(err, Movie) {
        var bitterMoon;
        bitterMoon = new Movie({
          title: 'Bitter Moon'
        });
        return bitterMoon.save(function(err) {
          var uid;
          expect(err).to.be(null);
          uid = bitterMoon.data.uid;
          expect(uid).to.be.a('number');
          return Movie.findAll().where({
            uid: uid
          }, function(err, found) {
            expect(err).to.be(null);
            expect(found).to.have.length(1);
            expect(found[0].data.uid).to.be.equal(uid);
            expect(found[0].data.title).to.be.equal('Bitter Moon');
            expect(found[0].data.is_movie).to.be(true);
            expect(found[0].data.director).to.be.equal('Roman Polanski');
            expect(_.keys(found[0].data)).to.have.length(4);
            return bitterMoon.remove(function() {
              return done();
            });
          });
        });
      });
    });
  });
  describe('label nodes', function() {
    it('expect to save labeled node and request label(s)', function(done) {
      var node;
      node = new Node({
        name: 'Dave'
      });
      node.label = 'Person';
      return node.save(function(err, person, debug) {
        expect(err).to.be(null);
        expect(person.label).to.be.equal('Person');
        return node.requestLabels(function(err, labels) {
          expect(err).to.be(null);
          expect(labels).to.have.length(1);
          expect(labels[0]).to.be.equal('Person');
          return node.remove(function(err) {
            var Article, article, _ref1;
            expect(err).to.be(null);
            Article = (function(_super) {
              __extends(Article, _super);

              function Article() {
                _ref1 = Article.__super__.constructor.apply(this, arguments);
                return _ref1;
              }

              return Article;

            })(Node);
            Node.registerModel(Article);
            article = new Article({
              title: 'Title of the article'
            });
            return article.save(function() {
              return article.requestLabels(function(err, labels) {
                expect(labels).to.have.length(1);
                expect(labels[0]).to.be.equal('Article');
                return article.remove(function() {
                  return done();
                });
              });
            });
          });
        });
      });
    });
    it('expect to add, remove and update labels of a node', function(done) {
      var Person, _ref1;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        Person.prototype.fields = {
          defaults: {},
          indexes: {}
        };

        return Person;

      })(Node);
      Node.registerModel(Person);
      return new Person({
        name: 'Jeff Bridges'
      }).save(function(err, jeff) {
        return jeff.allLabels(function(err, labels) {
          expect(err).to.be(null);
          expect(labels).to.have.length(1);
          expect(_.keys(jeff.data)).to.have.length(1);
          expect(labels[0]).to.be.equal('Person');
          return jeff.addLabel('Actor', function(err) {
            expect(err).to.be(null);
            return jeff.addLabels(['Actor', 'Singer', 'Photographer'], function(err) {
              return jeff.allLabels(function(err, labels) {
                expect(err).to.be(null);
                expect(labels).to.have.length(4);
                return done();
              });
            });
          });
        });
      });
    });
    it('expect to replace labels of a node', function(done) {
      var Person, _ref1;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        Person.prototype.fields = {
          defaults: {},
          indexes: {}
        };

        return Person;

      })(Node);
      Node.registerModel(Person);
      return new Person({
        name: 'Walter Sobchak'
      }).save(function(err, walt) {
        return walt.allLabels(function(err, labels) {
          expect(err).to.be(null);
          expect(labels).to.have.length(1);
          expect(labels[0]).to.be('Person');
          return walt.replaceLabels(['Person', 'NRAMember'], function(err) {
            expect(err).to.be(null);
            return walt.allLabels(function(err, labels) {
              expect(err).to.be(null);
              expect(labels).to.have.length(2);
              expect(labels[0]).to.be.equal('Person');
              expect(labels[1]).to.be.equal('NRAMember');
              return done();
            });
          });
        });
      });
    });
    it('expect to set labels manually as array and persist them', function(done) {
      var n;
      n = new Node({
        date: new Date
      });
      n.labels = ['Person', 'Actor'];
      return n.save(function(err, node) {
        expect(err).to.be(null);
        expect(node.labels).to.have.length(2);
        return n.allLabels(function(err, labels) {
          expect(labels).to.have.length(2);
          return done();
        });
      });
    });
    it('expect to find labeled node, with and without class', function(done) {
      var Person, person, _ref1;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      Node.registerModel(Person);
      person = new Person({
        name: 'Dave'
      });
      return person.save(function(err, savedPerson, debug) {
        expect(person.label).to.be.equal('Person');
        expect(savedPerson.label).to.be.equal('Person');
        return done();
      });
    });
    it('expect to instantiateNodeAsModel() via convertToModel()', function() {
      var Person, n, _ref1;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        Person.prototype.fullname = function() {
          return this.data.name + " " + this.data.surname;
        };

        return Person;

      })(Node);
      Node.registerModel(Person);
      n = new Node({
        name: 'Philipp',
        surname: 'Staender'
      });
      n.id = n._id_ = 123;
      expect(n.toObject()).to.be.eql({
        id: 123,
        classification: 'Node',
        data: {
          name: 'Philipp',
          surname: 'Staender'
        },
        uri: null,
        label: null,
        labels: []
      });
      n = n.convertToModel('Person');
      n.setLabels('Person');
      expect(n.toObject()).to.be.eql({
        id: 123,
        classification: 'Node',
        data: {
          name: 'Philipp',
          surname: 'Staender'
        },
        uri: null,
        label: 'Person',
        labels: ['Person']
      });
      expect(n._constructor_name_).to.be.equal('Person');
      expect(n.fullname()).to.be.equal('Philipp Staender');
      n = new Node({
        name: 'Philipp',
        surname: 'Staender'
      });
      n.id = n._id_ = 123;
      n = Node.instantiateNodeAsModel(n, 'Person');
      expect(n.toObject()).to.be.eql({
        id: 123,
        classification: 'Node',
        data: {
          name: 'Philipp',
          surname: 'Staender'
        },
        uri: null,
        label: 'Person',
        labels: ['Person']
      });
      expect(n._constructor_name_).to.be.equal('Person');
      return expect(n.fullname()).to.be.equal('Philipp Staender');
    });
    it('expect to find node including labels', function(done) {
      var Person, _ref1;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        Person.prototype.fullname = function() {
          return this.data.name;
        };

        return Person;

      })(Node);
      Node.registerModel(Person);
      return new Person({
        name: 'Alice'
      }).save(function(err, alice) {
        return Person.findById(alice.id, function(err, alice) {
          expect(alice._constructor_name_).to.be.equal('Person');
          expect(alice.label).to.be.equal('Person');
          return done();
        });
      });
    });
    it('expect to enable and disable loading hook', function(done) {
      var Person, _ref1;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      Node.registerModel(Person);
      Person.prototype.disableLoading();
      return new Person({
        name: 'Alice'
      }).save(function(err, a) {
        return Person.findById(a.id, function(err, alice) {
          expect(err).to.be(null);
          expect(alice.label).to.be(null);
          expect(alice._is_loaded_).to.be(null);
          Person.prototype.enableLoading();
          return Person.findById(alice.id, function(err, alice) {
            expect(err).to.be(null);
            expect(alice.label).to.be.equal('Person');
            expect(alice._is_loaded_).to.be(true);
            return done();
          });
        });
      });
    });
    it('expect to find labeled nodes', function(done) {
      var Person, person, _ref1;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      Node.registerModel(Person);
      person = new Person({
        name: 'Dave'
      });
      return Node.findAll().match('n:Person').count(function(err, countBefore) {
        return person.save(function() {
          return Node.findAll().match('n:Person').count(function(err, count) {
            expect(err).to.be(null);
            expect(count).to.be.equal(countBefore + 1);
            return done();
          });
        });
      });
    });
    it('expect to find or create a node', function(done) {
      var User, uid, _ref1;
      uid = new Date().getTime();
      User = (function(_super) {
        __extends(User, _super);

        function User() {
          _ref1 = User.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        User.prototype.fields = {
          indexes: {
            uid: true,
            name: true
          }
        };

        return User;

      })(Node);
      Node.registerModel(User);
      return User.ensureIndex(function(err) {
        return User.findOrCreate({
          uid: uid,
          name: 'Node'
        }, function(err, found) {
          var id;
          expect(err).to.be(null);
          expect(found.data.uid).to.be.equal(uid);
          expect(found.data.name).to.be.equal('Node');
          expect(found.id).to.be.above(0);
          id = found.id;
          return User.findOrCreate({
            uid: uid
          }, function(err, found, debug) {
            expect(err).to.be(null);
            expect(found.id).to.be.equal(id);
            uid = new Date().getTime();
            return User.findOrCreate({
              uid: uid,
              name: 'Node'
            }, function(err, found) {
              expect(err).to.be(null);
              expect(found.data.uid).to.be.equal(uid);
              return User.findOrCreate({
                name: 'Node'
              }, function(err, res) {
                expect(err.message).to.be.equal('More than one node found… You have query one distinct result');
                return done();
              });
            });
          });
        });
      });
    });
    return it('expect to check if node is persisted', function(done) {
      var n;
      n = new Node();
      expect(n.isPersisted()).to.be(false);
      return n.save(function(err, node) {
        expect(err).to.be(null);
        expect(node.isPersisted()).to.be(true);
        node.data.name = 'changed value';
        expect(node.isPersisted()).to.be(false);
        return node.save(function(err, node) {
          expect(err).to.be(null);
          expect(node.isPersisted()).to.be(true);
          return Node.findById(node.id, function(err, node) {
            expect(err).to.be(null);
            expect(node.isPersisted()).to.be(true);
            return done();
          });
        });
      });
    });
  });
  describe('index', function() {
    return it('expect to set default values and index values', function(done) {
      var node;
      Node.prototype.fields.defaults = {
        uid: function() {
          return generateUID();
        },
        nested: {
          hasValue: true
        }
      };
      node = new Node();
      node.data.name = 'Steve';
      return node.save(function(err, n) {
        expect(err).to.be(null);
        expect(node.data.uid).to.have.length(32);
        expect(node.data.nested.hasValue).to.be(true);
        return done();
      });
    });
  });
  describe('relationships (incoming, outgoing and between nodes)', function() {
    it('expect to create a relationship between nodes in any direction', function(done) {
      var alice, bob, charles;
      alice = new Node({
        name: 'Alice'
      });
      bob = new Node({
        name: 'Bob'
      });
      charles = new Node({
        name: 'Charles'
      });
      return alice.save(function() {
        return bob.save(function() {
          return charles.save(function() {
            return new Graph().countRelationships(function(err, countedRelationshipsBefore) {
              var e;
              try {
                alice.createRelationBetween(bob, function() {});
              } catch (_error) {
                e = _error;
                expect(e).to.be.an(Error);
              }
              try {
                alice.createRelationBetween(bob, {
                   since: 'years'
                }, function() {});
              } catch (_error) {
                e = _error;
                expect(e).to.be.an(Error);
              }
              return alice.createRelationBetween(bob, 'knows', {
                since: 'years'
              }, function(err, result) {
                expect(err).to.be(null);
                expect(result).to.have.length(2);
                return new Graph().countRelationships(function(err, countedRelationshipsIntermediate) {
                  expect(countedRelationshipsBefore + 2).to.be.equal(countedRelationshipsIntermediate);
                  return bob.createRelationTo(alice, 'liked', function(err, relationship) {
                    expect(err).to.be(null);
                    expect(relationship).to.be.an('object');
                    expect(relationship.type).to.be.equal('liked');
                    expect(relationship).to.be.an('object');
                    return new Graph().countRelationships(function(err, countedRelationshipsFinally) {
                      expect(countedRelationshipsBefore + 3).to.be.equal(countedRelationshipsFinally);
                      return bob.createRelationFrom(alice, 'follows', function(err, relationship) {
                        expect(err).to.be(null);
                        expect(relationship).to.be.an('object');
                        return new Graph().countRelations(function(err, countedRelationshipsFinally) {
                          expect(countedRelationshipsBefore + 4).to.be.equal(countedRelationshipsFinally);
                          return bob.createOrUpdateRelationFrom(alice, 'follows', {
                            since: 'years'
                          }, function(err, relationship, debug) {
                            var id;
                            expect(err).to.be(null);
                            expect(relationship).to.be.an('object');
                            expect(relationship.type).to.be.equal('follows');
                            expect(relationship.data.since).to.be.equal('years');
                            expect(relationship.id).to.be.a('number');
                            id = relationship.id;
                            return new Graph().countRelations(function(err, count) {
                              expect(count).to.be.equal(countedRelationshipsFinally);
                              return bob.createOrUpdateRelationFrom(alice, 'follows', {
                                since: 'months'
                              }, function(err, relationship) {
                                expect(err).to.be(null);
                                expect(relationship).to.be.an('object');
                                expect(relationship.type).to.be.a('string');
                                expect(relationship.data.since).to.be.equal('months');
                                expect(relationship.id).to.be.equal(id);
                                return new Graph().countRelations(function(err, count) {
                                  expect(count).to.be.equal(countedRelationshipsFinally);
                                  return charles.createOrUpdateRelationTo(bob, 'follows', {
                                    since: 'days'
                                  }, function(err, relationship) {
                                    expect(err).to.be(null);
                                    return bob.incomingRelations().count(function(err, count) {
                                      expect(count).to.be(3);
                                      return new Graph().countRelations(function(err, count) {
                                        expect(count).to.be.equal(countedRelationshipsFinally + 1);
                                        return alice.removeIncludingRelations(function() {
                                          return bob.removeIncludingRelations(function() {
                                            return charles.removeIncludingRelations(function() {
                                              return done();
                                            });
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    it('expect to create and get incoming, outgoing and bidirectional relationships between two nodes', function(done) {
      var node;
      node = new Node();
      node.data.name = "Alice";
      return node.save(function(err, a) {
        expect(a.hasId()).to.be(true);
        return a.outgoingRelations().count(function(err, count) {
          expect(count).to.be(0);
          node = new Node();
          node.data.name = "Bob";
          return node.save(function(err, b) {
            expect(b.hasId()).to.be(true);
            return a.createRelationTo(b, 'KNOWS', {
              since: 'years'
            }, function(err, result) {
              expect(err).to.be(null);
              return a.outgoingRelations().count(function(err, countNew) {
                expect(countNew).to.be(1);
                return a.outgoingRelations(function(err, outgoingRelationships, debug) {
                  expect(err).to.be(null);
                  expect(outgoingRelationships).to.have.length(1);
                  expect(outgoingRelationships[0].type).to.be.equal('KNOWS');
                  expect(outgoingRelationships[0].data.since).to.be.equal('years');
                  expect(outgoingRelationships[0].from).to.be.an('object');
                  expect(outgoingRelationships[0].from.id).to.be.a('number');
                  expect(outgoingRelationships[0].from.uri).to.be.a('string');
                  expect(outgoingRelationships[0].to).to.be.an('object');
                  expect(outgoingRelationships[0].to.id).to.be.a('number');
                  expect(outgoingRelationships[0].to.uri).to.be.a('string');
                  expect(outgoingRelationships[0].toObject()).to.be.an('object');
                  return a.createRelationFrom(b, 'LIKES', function(err, result) {
                    expect(err).to.be(null);
                    return a.incomingRelations('LIKES', function(err, result) {
                      expect(outgoingRelationships).to.have.length(1);
                      expect(err).to.be(null);
                      return a.createRelationBetween(b, 'LIKES', function(err, result, debug) {
                        expect(err).to.be(null);
                        return a.allRelations('LIKES', function(err, result) {
                          expect(err).to.be(null);
                          expect(result).to.have.length(3);
                          return done();
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    it('expect to get relations to labels', function(done) {
      var Person;
      Person = Node.registerModel('Person');
      return Person.create({
        name: generateUID()
      }, function(err, p1) {
        return Person.create({
          name: generateUID()
        }, function(err, p2) {
          return Node.create({
            name: generateUID()
          }, function(err, node) {
            return node.createRelationTo(p1, 'know', function() {
              return node.createRelationTo(p2, 'know', function() {
                return node.outgoingRelationsTo('Person', function(err, relationships) {
                  expect(err).to.be(null);
                  expect(relationships).to.have.length(2);
                  return done();
                });
              });
            });
          });
        });
      });
    });
    it('expect to create and update relationships with default values', function(done) {
      Relationship.setDefaultFields({
        created_on: function() {
          return new Date().getTime();
        }
      });
      return new Node({
        name: 'Alice'
      }).save(function(err, alice) {
        return new Node({
          name: 'Bob'
        }).save(function(err, bob) {
          return alice.createRelationBetween(bob, 'like', {
            since: 'years',
            nested: {
              values: true
            }
          }, function() {
            return alice.allRelations('like', function(err, relationships) {
              var i, relationship, _i, _len;
              expect(err).to.be(null);
              expect(relationships).to.have.length(2);
              for (i = _i = 0, _len = relationships.length; _i < _len; i = ++_i) {
                relationship = relationships[i];
                expect(relationship.id).to.be.above(0);
                expect(relationship.data.since).to.be.equal('years');
                expect(relationship.data.nested.values).to.be.equal(true);
                expect(relationship.data.created_on).to.be.above(0);
              }
              return alice.incomingRelations(function(err, relationship) {
                var r;
                r = new Relationship();
                expect(relationship).to.have.length(1);
                Relationship.setDefaultFields({});
                r = Relationship.create('know', {
                   since: 'years'
                }, alice.uri, bob.uri);
                expect(r.isPersisted()).to.be(false);
                expect(r.start).to.be(null);
                expect(r.end).to.be(null);
                expect(r.id).to.be(null);
                expect(r.type).to.be('know');
                expect(r.data).to.be.eql({
                  since: 'years'
                });
                expect(r.classification).to.be('Relationship');
                return r.save(function(err, r, debug) {
                  var id;
                  id = r.id;
                  expect(id).to.be.above(0);
                  expect(r.type).to.be('know');
                  expect(r.data).to.be.eql({
                    since: 'years'
                  });
                  return Relationship.findById(id, function(err, foundRelation) {
                    expect(err).to.be(null);
                    expect(foundRelation.id).to.be.equal(id);
                    expect(foundRelation.type).to.be('know');
                    expect(foundRelation.data).to.be.eql({
                      since: 'years'
                    });
                    r.data = {
                      since: 'a while',
                      year: 2000
                    };
                    r.type = 'like';
                    return r.save(function(err, newRelation, debug) {
                      expect(err).to.be(null);
                      expect(newRelation.id).to.be.above(id);
                      expect(newRelation.data).to.be.eql({
                        since: 'a while',
                        year: 2000
                      });
                      expect(newRelation.type).to.be('like');
                      return Relationship.findById(id, function(err, oldRelation) {
                        expect(err).to.be(null);
                        expect(oldRelation).to.be(null);
                        return Relationship.findById(newRelation.id, function(err, foundRelation) {
                          expect(foundRelation.data).to.be.eql(newRelation.data);
                          expect(foundRelation.type).to.be(newRelation.type);
                          return done();
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    return it('expect to get start and end nodes from relationships', function(done) {
      return new Node({
        name: 'Alice'
      }).save(function(err, alice) {
        return new Node({
          name: 'Bob'
        }).save(function(err, bob) {
          return new Node({
            name: 'Charles'
          }).save(function(err, charles) {
            expect(alice.data.name).to.be('Alice');
            expect(bob.data.name).to.be('Bob');
            return alice.createOrUpdateRelationBetween(bob, 'know', function(err) {
              expect(err).to.be(null);
              return charles.createRelationTo(alice, 'know', function(err) {
                expect(err).to.be(null);
                return alice.incomingRelations('know', function(err, result) {
                  expect(result).to.have.length(2);
                  expect(result[0].to.id).to.be.above(0);
                  expect(result[1].to.id).to.be.above(0);
                  return done();
                });
              });
            });
          });
        });
      });
    });
  });
  describe('queries acceptance', function() {
    it('expect to query nodes with regex', function(done) {
      var Person, uid;
      uid = new Date().getTime();
      Person = Node.registerModel('Person');
      return new Person({
        uid: uid,
        name: 'Alice'
      }).save(function(err, alice) {
        expect(err).to.be(null);
        return Person.find({
          uid: uid,
          name: /^alice$/i
        }, function(err, found, debug) {
          var p;
          expect(err).to.be(null);
          expect(found).to.have.length(1);
          p = found[0];
          expect(p.data.uid).to.be.equal(uid);
          expect(p.data.name).to.be.equal(alice.data.name);
          return done();
        });
      });
    });
    return it('expect to query correctly with $and|$or|$not and HAS() with and without paramaters', function(done) {
      var labelName;
      labelName = "Label" + (generateUID());
      return Node.registerModel(labelName, {
        fields: {
           indexes: {
             email: true
          }
        }
      }, function(err, Model) {
        return new Model({
          email: 'jackblack@tenacio.us',
          job: 'Actor'
        }).save(function(err, jb) {
          expect(err).to.be(null);
          return new Model({
            name: 'Jack Black',
            job: 'Actor'
          }).save(function(err, jb) {
            var where;
            expect(err).to.be(null);
            where = {
              $and: [
                {
                  job: 'Actor'
                }, {
                  $or: [
                    {
                      email: /^jackblack@tenacio\.us$/
                    }, {
                      name: 'Jack Black'
                    }
                  ]
                }
              ]
            };
            helpers.CypherQuery.prototype.useParameters = false;
            expect(Model.find(where).toCypherQuery().replace(/\n+/g, ' ').replace(/\s+/g, ' ')).to.be.equal("START n = node(*) MATCH (n:" + labelName + ") WHERE ( ( HAS (n.`job`) AND n.`job` = 'Actor' AND ( HAS (n.`email`) AND n.`email` =~ '^jackblack@tenacio\\\\.us$' OR HAS (n.`name`) AND n.`name` = 'Jack Black' ) ) ) RETURN n, labels(n);");
            return Model.find(where, function(err, found) {
              expect(err).to.be(null);
              expect(found).to.have.length(2);
              helpers.CypherQuery.prototype.useParameters = true;
              return Model.find(where, function(err, found) {
                expect(err).to.be(null);
                expect(found).to.have.length(2);
                return done();
              });
            });
          });
        });
      });
    });
  });
  describe('path algorithms', function() {
    return it('expect to find shortest path between two nodes', function(done) {
      var a;
      a = new Node({
        name: 'Alice'
      });
      return a.save(function(err) {
        var b;
        b = new Node({
          name: 'Bob'
        });
        return b.save(function() {
          var c;
          c = new Node({
            name: 'Charles'
          });
          return c.save(function() {
            return a.createRelationTo(b, 'KNOWS', function() {
              return b.createRelationTo(c, 'KNOWS', function() {
                return a.shortestPathTo(c, 'KNOWS', function(err, path, debug) {
                  expect(err).to.be(null);
                  expect(path.length).to.be(2);
                  expect(path.nodes).to.have.length(3);
                  expect(path.nodes[0].uri).to.be.a('string');
                  expect(path.nodes[0].id).to.be.a('number');
                  expect(path.relationships).to.have.length(2);
                  expect(path.relationships[0].uri).to.be.a('string');
                  expect(path.relationships[0].id).to.be.a('number');
                  expect(path.start).to.be.a('string');
                  expect(path.end).to.be.a('string');
                  expect(path.toObject()).to.be.an('object');
                  return a.removeIncludingRelations(function(err) {
                    expect(err).to.be(null);
                    return b.removeIncludingRelations(function(err) {
                      expect(err).to.be(null);
                      return done();
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
  return describe('relationship', function() {
    it('expect to get a relationship by id', function(done) {
      return new Node().save(function(err, a) {
        return new Node().save(function(err, b) {
          return a.createRelationTo(b, 'related', {
            since: 'year'
          }, function(err, result) {
            expect(result.id).to.be.above(0);
            return Relationship.findById(result.id, function(err, found) {
              expect(err).to.be(null);
              expect(found.id).to.be.equal(result.id);
              expect(found.data.since).to.be.equal('year');
              return Relationship.findById(new Date().getTime(), function(err, found) {
                expect(err).to.be(null);
                expect(found).to.be(null);
                return done();
              });
            });
          });
        });
      });
    });
    it('expect to update a relationship', function(done) {
      return new Node().save(function(err, a) {
        return new Node().save(function(err, b) {
          return a.createRelationTo(b, 'related', {
            since: 'year'
          }, function(err, relationship) {
            var id;
            expect(err).to.be(null);
            id = relationship.id;
            expect(id).to.be.a('number');
            relationship.data.from = 'Berlin';
            return relationship.save(function(err, relationship) {
              expect(err).to.be(null);
              expect(relationship.id).to.be.equal(id);
              expect(relationship.data.from).to.be.equal('Berlin');
              return done();
            });
          });
        });
      });
    });
    it('expect to remove a relationship', function(done) {
      return new Node().save(function(err, a) {
        return new Node().save(function(err, b) {
          return a.createRelationTo(b, 'related', {
            since: 'year'
          }, function(err, relationship) {
            var id;
            expect(err).to.be(null);
            id = relationship.id;
            expect(id).to.be.a('number');
            return relationship.remove(function(err) {
              expect(err).to.be(null);
              return Relationship.findById(id, function(err, found) {
                expect(err).to.be(null);
                expect(found).to.be(null);
                return done();
              });
            });
          });
        });
      });
    });
    it('expect to trigger load hook and loading both nodes on getById', function(done) {
      return new Node({
        name: 'Alice'
      }).save(function(err, a) {
        return new Node({
          name: 'Bob'
        }).save(function(err, b) {
          return a.createRelationTo(b, 'related', {
            since: 'year'
          }, function(err, result) {
            expect(err).to.be(null);
            return Relationship.findById(result.id, function(err, relationship) {
              expect(err).to.be(null);
              expect(relationship.from.data.name).to.be.equal('Alice');
              expect(relationship.to.data.name).to.be.equal('Bob');
              return done();
            });
          });
        });
      });
    });
    it('expect to update a relationship with preventing id accidently changing and with value extending', function(done) {
      return new Node({
        name: 'Alice'
      }).save(function(err, a) {
        return new Node({
          name: 'Bob'
        }).save(function(err, b) {
          return a.createRelationTo(b, 'related', {
            since: 'years',
            city: 'Berlin'
          }, function(err, relationship) {
            expect(err).to.be(null);
            return Relationship.findById(relationship.id, function(err, relationship) {
              expect(relationship.data.since).to.be.equal('years');
              expect(relationship.data.city).to.be.equal('Berlin');
              return relationship.update({
                since: 'months'
              }, function(err, updatedRelationship) {
                var id;
                expect(relationship.data.since).to.be.equal('months');
                expect(relationship.data.city).to.be.equal('Berlin');
                expect(updatedRelationship.data.since).to.be.equal('months');
                expect(updatedRelationship.data.city).to.be.equal('Berlin');
                id = relationship.id;
                relationship.id = -2;
                relationship.data.city = 'Cologne';
                return relationship.save(function(err, updatedRelationship) {
                  expect(err).to.be(null);
                  expect(relationship.id).to.equal(id);
                  expect(updatedRelationship.data.since).to.be.equal('months');
                  expect(updatedRelationship.data.city).to.be.equal('Cologne');
                  expect(relationship.data.since).to.be.equal('months');
                  expect(relationship.data.city).to.be.equal('Cologne');
                  return relationship.update({
                    since: 'weeks'
                  }, function(err, updatedRelationship) {
                    expect(err).to.be(null);
                    expect(relationship.id).to.equal(id);
                    expect(updatedRelationship.data.since).to.be.equal('weeks');
                    expect(updatedRelationship.data.city).to.be.equal('Cologne');
                    return done();
                  });
                });
              });
            });
          });
        });
      });
    });
    return it('expect to have schema like behaviour on relationships', function(done) {
      Relationship.setDefaultFields({
        created_on: function() {
          return String(new Date);
        },
        checked: true
      });
      return new Node({
        name: 'Alice'
      }).save(function(err, a) {
        return new Node({
          name: 'Bob'
        }).save(function(err, b) {
          return a.createRelationTo(b, 'knows', function(err, r) {
            expect(err).to.be(null);
            expect(r.data.created_on).to.be.a('string');
            expect(r.data.checked).to.be.equal(true);
            return done();
          });
        });
      });
    });
  });
});
