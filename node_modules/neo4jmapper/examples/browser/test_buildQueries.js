// Generated by CoffeeScript 1.6.3
var Graph, Join, Neo4j, Neo4jRestful, Node, Path, Relationship, Transaction, client, configForTest, expect, helpers, neo4jmapper, _, _ref, _trim,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof root !== "undefined" && root !== null) {
  require('source-map-support').install();
  expect = require('expect.js');
  Join = require('join');
  _ = require('underscore');
  configForTest = require('./config');
  Neo4j = require("../" + configForTest.srcFolder + "/index.js");
  _ref = new Neo4j({
    url: configForTest.neo4jURL,
    onConnectionError: function(err) {
      throw err;
    }
  }), Graph = _ref.Graph, Node = _ref.Node, Relationship = _ref.Relationship, Path = _ref.Path, Transaction = _ref.Transaction, Neo4jRestful = _ref.Neo4jRestful, helpers = _ref.helpers, client = _ref.client;
} else {
  _ = window._;
  configForTest = _.extend({
    doLog: false,
    wipeDatabase: false,
    neo4jURL: 'http://yourserver:0000/'
  }, configForTest || {});
  Join = window.Join;
  neo4jmapper = new window.Neo4jMapper(configForTest.neo4jURL);
  Graph = neo4jmapper.Graph, Node = neo4jmapper.Node, Relationship = neo4jmapper.Relationship, Path = neo4jmapper.Path, Transaction = neo4jmapper.Transaction, Neo4jRestful = neo4jmapper.Neo4jRestful, helpers = neo4jmapper.helpers, client = neo4jmapper.client;
  Neo4j = Neo4jMapper;
}

if (configForTest.doLog) {
  client.constructor.prototype.log = Graph.prototype.log = configForTest.doLog;
}

_trim = function(s) {
  return s.trim().replace(/\s+/g, ' ');
};

describe('Neo4jMapper (cypher queries)', function() {
  it('expect to throw an error on some specific chaining cases', function() {
    var e, err;
    err = null;
    try {
      Node.findOne().deleteIncludingRelations(function() {});
    } catch (_error) {
      e = _error;
      err = e;
    }
    expect(err).not.to.be(null);
    err = null;
    try {
      Node.find().deleteIncludingRelations().limit(1, function() {});
    } catch (_error) {
      e = _error;
      err = e;
    }
    return expect(err).not.to.be(null);
  });
  return it('expect to build various kind of queries', function() {
    var Actor, functionCall, i, key, map, node, query, queryString, results, testQueries, todo, trimQueryString, value, _ref1, _ref2;
    expect(helpers.CypherQuery.prototype.useParameters).to.be(true);
    Actor = (function(_super) {
      __extends(Actor, _super);

      function Actor() {
        _ref1 = Actor.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      return Actor;

    })(Node);
    Node.register_model(Actor);
    node = new Node();
    results = [];
    testQueries = function() {
      return {
        "Node.findAll()": [Node.findAll(), 'START n = node(*) RETURN n, labels(n);'],
        "Node.findById(123)": [Node.findById(123), "START n = node(123) RETURN n, labels(n);"],
        'Node.findOne()': [Node.findOne(), 'START n = node(*) RETURN n, labels(n) LIMIT 1;'],
        "Node.findAll().limit(10)": [Node.findAll().limit(10), 'START n = node(*) RETURN n, labels(n) LIMIT 10;'],
        "Node.findAll().match('n:Person')": [Node.findAll().match('n:Person'), "MATCH (n:Person) RETURN n, labels(n);"],
        "Actor.findById(123)": [Actor.findById(123), "START n = node(123) MATCH (n:Actor) RETURN n, labels(n);"],
        "Actor.findAll()": [Actor.findAll(), "MATCH (n:Actor) RETURN n, labels(n);"],
        "Node.findAll().skip(5)": [Node.findAll().skip(5), 'START n = node(*) RETURN n, labels(n) SKIP 5;'],
        "Node.start().match('(p:PERSON)-[:KNOWS]->(a:Actor)-[:ACTS]->(m:Movie)').return('p AS Person')": [Node.start().match('(p:PERSON)-[:KNOWS]->(a:Actor)-[:ACTS]->(m:Movie)')["return"]('p AS Person'), 'MATCH (p:PERSON)-[:KNOWS]->(a:Actor)-[:ACTS]->(m:Movie) RETURN p AS Person;'],
        "Node.findAll().orderBy( { 'name': 'DESC' } )": [
          Node.findAll().orderBy({
            'name': 'DESC'
          }), 'START n = node(*) WHERE HAS (n.`name`) RETURN n, labels(n) ORDER BY n.`name` DESC;'
        ],
        "Node.findAll().orderNodeBy({'name': 'ASC'})": [
          Node.findAll().orderNodeBy({
            'name': 'ASC'
          }), 'START n = node(*) WHERE HAS (n.`name`) RETURN n, labels(n) ORDER BY n.`name` ASC;'
        ],
        'Node.findAll().incomingRelations()': [Node.findAll().incomingRelations(), 'START n = node(*) MATCH (n)<-[r]-() RETURN r;'],
        'Node.findById(123).incomingRelations("Person")': [Node.findById(123).incomingRelationsFrom("Person"), 'START n = node(123) MATCH (n)<-[r]-(:Person) RETURN r;'],
        'Actor.findAll().incomingRelations()': [Actor.findAll().incomingRelations(), 'START n = node(*) MATCH (n:Actor)<-[r]-() RETURN r;'],
        'Node.findAll().outgoingRelations()': [Node.findAll().outgoingRelations(), 'START n = node(*) MATCH (n)-[r]->() RETURN r;'],
        "Node.findAll().incomingRelations()": [Node.findAll().incomingRelations(), 'START n = node(*) MATCH (n)<-[r]-() RETURN r;'],
        "Node.findOne().withRelations('know')": [Node.findOne().withRelations('know'), "MATCH (n)-[r:know]-() RETURN n, labels(n) LIMIT 1;"],
        "Node.findOne().outgoingRelations(['know','like'])": [Node.findOne().outgoingRelations(['know', 'like']), 'START n = node(*) MATCH (n)-[r:know|like]->() RETURN r LIMIT 1;'],
        "Node.findOne().outgoingRelationsTo(2, ['know','like'])": [Node.findOne().outgoingRelationsTo(2, ['know', 'like']), 'START n = node(*), m = node(2) MATCH (n)-[r:know|like]->(m) RETURN r LIMIT 1;'],
        "Node.findOne().outgoingRelationsTo(2, 'know|like*')": [Node.findOne().outgoingRelationsTo(2, 'know|like*'), 'START n = node(*), m = node(2) MATCH (n)-[r:know|like*]->(m) RETURN r LIMIT 1;'],
        "Node.findOne().where({ 'name?': 'Alice'})": [
          Node.findOne().where({
            'name?': 'Alice'
          }), "START n = node(*) WHERE ( n.`name`? = 'Alice' ) RETURN n, labels(n) LIMIT 1;", "START n = node(*) WHERE ( n.`name`? = {_value0_} ) RETURN n, labels(n) LIMIT 1;", {
            _value0_: 'Alice'
          }
        ],
        "Node.findOne().where({name: 'Alice'}).outgoingRelations()": [
          Node.findOne().where({
            name: 'Alice'
          }).outgoingRelations(), "START n = node(*) MATCH (n)-[r]->() WHERE ( HAS (n.`name`) AND n.`name` = 'Alice' ) RETURN r LIMIT 1;", "START n = node(*) MATCH (n)-[r]->() WHERE ( HAS (n.`name`) AND n.`name` = {_value0_} ) RETURN r LIMIT 1;", {
            _value0_: 'Alice'
          }
        ],
        "Node.findAll().outgoingRelations('know').distinct().count()": [Node.findAll().outgoingRelations('know').distinct().count(), 'START n = node(*) MATCH (n)-[r:know]->() RETURN COUNT(DISTINCT *);'],
        "Node.singleton(1).incomingRelationsFrom(2, 'like').where({ 'since': 'years' })": [
          Node.singleton(1).incomingRelationsFrom(2, 'like').where({
            'since': 'years'
          }), "START n = node(1), m = node(*) MATCH (n)<-[r:like]-(m) WHERE ( HAS (n.`since`) AND n.`since` = 'years' ) RETURN r, n, labels(n);", "START n = node(1), m = node(*) MATCH (n)<-[r:like]-(m) WHERE ( HAS (n.`since`) AND n.`since` = {_value0_} ) RETURN r, n, labels(n);", {
            _value0_: 'years'
          }
        ],
        "Node.singleton(1).incomingRelationsFrom(2, 'like').whereRelationship({ 'since': 'years' })": [
          Node.singleton(1).incomingRelationsFrom(2, 'like').whereRelationship({
            'since': 'years'
          }), "START n = node(1), m = node(*), r = relationship(*) MATCH (n)<-[r:like]-(m) WHERE ( HAS (r.`since`) AND r.`since` = 'years' ) RETURN r;", "START n = node(1), m = node(*), r = relationship(*) MATCH (n)<-[r:like]-(m) WHERE ( HAS (r.`since`) AND r.`since` = {_value0_} ) RETURN r;", {
            _value0_: 'years'
          }
        ],
        "Node.find().whereNode({ 'boolean_a': true, 'boolean_b': false, 'string_a': 'true', 'number_a': 123.2, 'number_b': 123, 'string_b': '123', 'regex': /[a-z]/ })": [
          Node.find().whereNode({
            'boolean_a': true,
            'boolean_b': false,
            'string_a': 'true',
            'number_a': 123.2,
            'number_b': 123,
            'string_b': '123',
            'regex': /[a-z]/
          }), "START n = node(*) WHERE ( HAS (n.`boolean_a`) AND n.`boolean_a` = true AND HAS (n.`boolean_b`) AND n.`boolean_b` = false AND HAS (n.`string_a`) AND n.`string_a` = 'true' AND HAS (n.`number_a`) AND n.`number_a` = 123.2 AND HAS (n.`number_b`) AND n.`number_b` = 123 AND HAS (n.`string_b`) AND n.`string_b` = '123' AND HAS (n.`regex`) AND n.`regex` =~ '[a-z]' ) RETURN n, labels(n);", "START n = node(*) WHERE ( HAS (n.`boolean_a`) AND n.`boolean_a` = {_value0_} AND HAS (n.`boolean_b`) AND n.`boolean_b` = {_value1_} AND HAS (n.`string_a`) AND n.`string_a` = {_value2_} AND HAS (n.`number_a`) AND n.`number_a` = {_value3_} AND HAS (n.`number_b`) AND n.`number_b` = {_value4_} AND HAS (n.`string_b`) AND n.`string_b` = {_value5_} AND HAS (n.`regex`) AND n.`regex` =~ {_value6_} ) RETURN n, labels(n);", {
            _value0_: true,
            _value1_: false,
            _value2_: 'true',
            _value3_: 123.2,
            _value4_: 123,
            _value5_: '123',
            _value6_: '[a-z]'
          }
        ],
        "Node.find({ $and : [ { a: 1 }, { b: 2} ] })": [
          Node.find({
            $and: [
              {
                a: 1
              }, {
                b: 2
              }
            ]
          }), "START n = node(*) WHERE ( ( HAS (n.`a`) AND n.`a` = 1 AND HAS (n.`b`) AND n.`b` = 2 ) ) RETURN n, labels(n);", "START n = node(*) WHERE ( ( HAS (n.`a`) AND n.`a` = {_value0_} AND HAS (n.`b`) AND n.`b` = {_value1_} ) ) RETURN n, labels(n);", {
            _value0_: 1,
            _value1_: 2
          }
        ],
        "Node.find().where( { $or : [ { 'n.name': /alice/i } , { 'n.name': /bob/i } ] }).skip(2).limit(10).orderBy({ name: 'DESC'})": [
          Node.find().where({
            $or: [
              {
                'n.firstname': /alice/i
              }, {
                'n.surname': /bob/i
              }
            ]
          }).skip(2).limit(10).orderBy({
            name: 'DESC'
          }), "START n = node(*) WHERE HAS (n.`name`) AND ( ( HAS (n.`firstname`) AND n.`firstname` =~ '(?i)alice' OR HAS (n.`surname`) AND n.`surname` =~ '(?i)bob' ) ) RETURN n, labels(n) ORDER BY n.`name` DESC SKIP 2 LIMIT 10;", "START n = node(*) WHERE HAS (n.`name`) AND ( ( HAS (n.`firstname`) AND n.`firstname` =~ {_value0_} OR HAS (n.`surname`) AND n.`surname` =~ {_value1_} ) ) RETURN n, labels(n) ORDER BY n.`name` DESC SKIP 2 LIMIT 10;", {
            _value0_: '(?i)alice',
            _value1_: '(?i)bob'
          }
        ],
        "Actor.find().where( { $or : [ { 'n.name': /alice/i } , { 'n.name': /bob/i } ] }).skip(2).limit(10).orderBy({ name: 'DESC'})": [
          Actor.find().where({
            $or: [
              {
                'n.name': /alice/i
              }, {
                'n.name': /bob/i
              }
            ]
          }).skip(2).limit(10).orderBy({
            name: 'DESC'
          }), "START n = node(*) MATCH (n:Actor) WHERE HAS (n.`name`) AND ( ( HAS (n.`name`) AND n.`name` =~ '(?i)alice' OR HAS (n.`name`) AND n.`name` =~ '(?i)bob' ) ) RETURN n, labels(n) ORDER BY n.`name` DESC SKIP 2 LIMIT 10;"
        ],
        "Node.findOne().where({ 'n.city': 'berlin' }).andHasProperty('name').return('n AS Person')": [
          Node.findOne().where({
            'n.city': 'berlin'
          }).andHasProperty('name')["return"]('n AS Person'), "START n = node(*) WHERE HAS (n.`name`) AND ( HAS (n.`city`) AND n.`city` = 'berlin' ) RETURN n AS Person, labels(n) LIMIT 1;"
        ],
        "Node.findOne([ { 'n.city': 'berlin' } , $and: [ { 'n.name': 'peter' }, $not: [ { 'n.name': 'pedro' } ] ] ]).return('n.name AS Name')": [
          Node.findOne([
            {
              'n.city': 'berlin'
            }, {
              $and: [
                {
                  'n.name': 'peter'
                }, {
                  $not: [
                    {
                      'n.name': 'pedro'
                    }
                  ]
                }
              ]
            }
          ])["return"]('n.name AS Name'), "START n = node(*) WHERE ( HAS (n.`city`) AND n.`city` = 'berlin' AND ( HAS (n.`name`) AND n.`name` = 'peter' AND NOT ( HAS (n.`name`) AND n.`name` = 'pedro' ) ) ) RETURN n.name AS Name LIMIT 1;"
        ],
        " Node.find({ foo: 'bar' }).where('(n)-[:KNOW]-()')": [
          Node.find({
            foo: 'bar'
          }).where('(n)-[:KNOW]-()'), "START n = node(*) WHERE ( HAS (n.`foo`) AND n.`foo` = 'bar' ) AND ( (n)-[:KNOW]-() ) RETURN n, labels(n);"
        ],
        "Node.findById(123).incomingRelations().delete()": [Node.findById(123).incomingRelations()["delete"](), "START n = node(123) MATCH (n)<-[r]-() DELETE r;"],
        "Node.findById(123).allRelations().delete()": [Node.findById(123).allRelations()["delete"](), "START n = node(123) MATCH (n)-[r]-() DELETE r;"],
        "Actor.deleteAllIncludingRelations()": [Actor.deleteAllIncludingRelations(), "START n = node(*) OPTIONAL MATCH (n:Actor)-[r]-() DELETE n, r;"],
        "Node.find().deleteIncludingRelations()": [Node.find().deleteIncludingRelations(), "START n = node(*) OPTIONAL MATCH (n)-[r]-() DELETE n, r;"],
        "Actor.find().deleteIncludingRelations()": [Actor.find().deleteIncludingRelations(), "START n = node(*) OPTIONAL MATCH (n:Actor)-[r]-() DELETE n, r;"],
        "Node.findById(123).update({ name: 'Alice', email: 'alice@home.com' })": [
          Node.findById(123).update({
            name: 'Alice',
            email: 'alice@home.com'
          }), "START n = node(123) SET n.`name` = 'Alice', n.`email` = 'alice@home.com' RETURN n, labels(n);", "START n = node({_node_id_}) SET n.`name` = {_value0_}, n.`email` = {_value1_} RETURN n, labels(n);", {
             _value0_: 'Alice',
            _value1_: 'alice@home.com',
            _node_id_: 123
          }
        ],
        "Node.findById(123).update({ 'name': 'Alice', 'age': 20 })": [
          Node.findById(123).update({
            'name': 'Alice',
            'age': 20
          }), "START n = node(123) SET n.`name` = 'Alice', n.`age` = 20 RETURN n, labels(n);"
        ],
        "Node.findOne().whereRelationship({ length: 20 })": [
          Node.findOne().whereRelationship({
            length: 20
          }), "START n = node(*), r = relationship(*) WHERE ( HAS (r.`length`) AND r.`length` = 20 ) RETURN n, r, labels(n) LIMIT 1;"
        ],
        "Node.findAll().where( { $and : [ { name: { $in: [ 'a', 'b', 1, 2 ] } }, mail: { $in: 1 } ] } )": [
          Node.findAll().where({
            $and: [
              {
                name: {
                  $in: ['a', 'b', 1, 2]
                }
              }, {
                mail: {
                  $in: 1
                }
              }
            ]
          }), "START n = node(*) WHERE ( ( HAS (n.`name`) AND n.`name` IN [ 'a', 'b', 1, 2 ] AND HAS (n.`mail`) AND n.`mail` IN [ ] ) ) RETURN n, labels(n);"
        ],
        "Graph.create()": [
          Graph.create({
            'n:Person': {
              name: 'Andres',
              title: 'Developer'
            }
          }), "CREATE ( n:Person { `name` : 'Andres', `title` : 'Developer' } );", "CREATE ( n:Person { `name` : {_value0_}, `title` : {_value1_} } );", {
            value0: 'Andres',
            value1: 'Developer'
          }
        ],
        "Graph.set()": [
          Graph.start('n = node(123)').set({
            "n.name": 'Philipp',
            "n.year": 1982,
            "n.surname": null
          }).setWith({
            n: {
              "name": 'Philipp',
              "year": 1982,
              "surname": null
            }
          }), "START n = node(123)\nSET n.`name` = 'Philipp', n.`year` = 1982, n.`surname` = NULL\nSET n = { `name` : 'Philipp', `year` : 1982, `surname` : NULL };", "START n = node(123)\nSET n.`name` = {_value0_}, n.`year` = {_value1_}, n.`surname` = {_value2_}\nSET n = { `name` : {_value3_}, `year` : {_value4_}, `surname` : {_value5_} };", {
            _value0_: 'Philipp',
            _value1_: 1982,
            _value2_: null,
            _value3_: 'Philipp',
            _value4_: 1982,
            _value5_: null
          }
        ],
        "Graph.start()…": [
          Graph.start('_start_').match('_match_').onMatch([
            '(on)-[r:RELTYPE ', {
              key1: 'value1',
              key2: 'value2'
            }, ']-(match)'
          ]).optionalMatch({
            key3: 'value3'
          }).where('n.name = {value1} OR n.name = {value2}').where({
            $OR: [
              {
                'n.name': 'Bob'
              }, {
                'n.name': 'bob'
              }
            ]
          }).where('n.name = {name}', {
            name: 'Lucy'
          }).addParameters({
            value1: 'Bob'
          }).addParameters({
            value2: 'bob'
          })["with"]('_with_').orderBy('_order by_').skip(0).limit(0)["delete"]('_delete_')["return"]('_return_').create('_create_').onCreate('_on create_').createUnique('_create unique_').merge('_merge_').remove('_remove_').set('_set_').foreach('_foreach_')["case"]('CASE  _case_   END').custom('custom statement').comment('comment'), "START _start_\nMATCH _match_\nON MATCH (on)-[r:RELTYPE { `key1` : 'value1', `key2` : 'value2' }]-(match)\nOPTIONAL MATCH { `key3` : 'value3' }\nWHERE n.name = {value1} OR n.name = {value2}\nWHERE ( HAS (n.`name`) AND n.`name` = 'Bob' OR HAS (n.`name`) AND n.`name` = 'bob' )\nWHERE n.name = {name}\nWITH _with_\nORDER BY _order by_\nSKIP 0\nLIMIT 0\nDELETE _delete_\nRETURN _return_\nCREATE _create_\nON CREATE _on create_\nCREATE UNIQUE _create unique_\nMERGE _merge_\nREMOVE _remove_\nSET _set_\nFOREACH _foreach_\nCASE _case_ END\ncustom statement\n/* comment */;", "START _start_\nMATCH _match_\nON MATCH (on)-[r:RELTYPE { `key1` : {_value0_}, `key2` : {_value1_} }]-(match)\nOPTIONAL MATCH { `key3` : {_value2_} }\nWHERE n.name = {value1} OR n.name = {value2}\nWHERE ( HAS (n.`name`) AND n.`name` = {_value3_} OR HAS (n.`name`) AND n.`name` = {_value4_} )\nWHERE n.name = {name}\nWITH _with_\nORDER BY _order by_\nSKIP 0\nLIMIT 0\nDELETE _delete_\nRETURN _return_\nCREATE _create_\nON CREATE _on create_\nCREATE UNIQUE _create unique_\nMERGE _merge_\nREMOVE _remove_\nSET _set_\nFOREACH _foreach_\nCASE _case_ END\ncustom statement\n/* comment */;", {
            _value0_: "value1",
            _value1_: "value2",
            _value2_: "value3",
            _value3_: "Bob",
            _value4_: "bob",
            name: 'Lucy',
            value1: "Bob",
            value2: "bob"
          }
        ],
        "Graph.start().match(…": [
          Graph.start().match('(game:Game)-[c:contains]->(position:Position)').comment('Select games with title "Wes vs Alvin"').where({
            'game.title': "Wes vs Alvin"
          })["with"]('game, collect(position) AS positions').match('game-[c:contains]->(position:Position)')["with"]('positions, c, position').orderBy({
            'c.move': 'ASC'
          }).match('position-[m:move]->next').where('next IN (positions)')["return"]('(c.move+1)/2 as move, position.to_move as player, m.move, next.score as score').limit(20), "MATCH (game:Game)-[c:contains]->(position:Position)\n/* Select games with title \"Wes vs Alvin\" */\nWHERE HAS (game.`title`) AND game.`title` = 'Wes vs Alvin'\nWITH game, collect(position) AS positions MATCH game-[c:contains]->(position:Position)\nWITH positions, c, position\nORDER BY c.move ASC\nMATCH position-[m:move]->next\nWHERE next IN (positions)\nRETURN (c.move+1)/2 as move, position.to_move as player, m.move, next.score as score\nLIMIT 20;", "MATCH (game:Game)-[c:contains]->(position:Position)\n/* Select games with title \"Wes vs Alvin\" */\nWHERE HAS (game.`title`) AND game.`title` = {_value0_}\nWITH game, collect(position) AS positions MATCH game-[c:contains]->(position:Position)\nWITH positions, c, position\nORDER BY c.move ASC\nMATCH position-[m:move]->next\nWHERE next IN (positions)\nRETURN (c.move+1)/2 as move, position.to_move as player, m.move, next.score as score\nLIMIT 20;", {
             _value0_: 'Wes vs Alvin'
          }
        ]
      };
    };
    helpers.CypherQuery.prototype.useParameters = false;
    map = testQueries();
    for (functionCall in map) {
      todo = map[functionCall];
      if ((todo != null ? todo[2] : void 0) === null) {
        console.log('pending ' + functionCall + ' ~> ' + _trim(todo[0].toCypherQuery()));
      } else if (_.isArray(todo)) {
        query = todo[0];
        query = query.toCypherQuery();
        query = _trim(query);
        if (query !== _trim(todo[1])) {
          throw Error("Error by building query " + functionCall + "\nExpected: " + (_trim(todo[1])) + "\nGot:      " + query);
        }
      } else {
        console.log('skipping ' + functionCall + ' ~> ' + _trim(todo.toCypherQuery()));
      }
    }
    helpers.CypherQuery.prototype.useParameters = true;
    map = testQueries();
    for (functionCall in map) {
      todo = map[functionCall];
      if ((todo != null ? todo[2] : void 0) === null) {
        console.log('pending ' + functionCall + ' ~> ' + _trim(todo[0].toCypherQuery()));
      } else if (_.isArray(todo)) {
        if (todo[2] && todo[3]) {
          query = todo[0];
          if (!query.toQuery().parameters) {
            throw Error("Expected parameter values for '" + todo[2] + "' instead of `" + query.toQuery().parameters + "`");
          }
          if (Object.keys(query.toQuery().parameters).length !== Object.keys(todo[3]).length) {
            throw Error(("Expected " + (Object.keys(todo[3]).length) + " parameter(s) on '" + functionCall + "': ") + JSON.stringify(todo[3]) + "\nGot " + JSON.stringify(query.toQuery().parameters));
          }
          i = 0;
          _ref2 = todo[3];
          for (key in _ref2) {
            value = _ref2[key];
            if (query.cypher.parameters[Object.keys(query.cypher.parameters)[i]] !== value) {
              throw Error(["Expected", "`" + query.cypher.parameters[Object.keys(query.cypher.parameters)[i]] + "`", "to be equal", "`" + value + "`", " for `" + todo[2]].join(' '));
            }
            i++;
          }
          queryString = query.toQuery().toCypher();
          trimQueryString = _trim(queryString);
          if (trimQueryString !== _trim(todo[2])) {
            throw Error("Error building query with parameters " + functionCall + "\nExpected: " + (_trim(todo[2])) + "\nGot:      " + trimQueryString);
          }
        }
      } else {
        console.log('skipping ' + functionCall + ' ~> ' + _trim(todo.toCypherQuery()));
      }
    }
    return helpers.CypherQuery.prototype.cypher.useParameters = true;
  });
});
