// Generated by CoffeeScript 1.6.3
var Graph, Join, Neo4j, Neo4jRestful, Node, Path, Relationship, Transaction, client, configForTest, expect, helpers, neo4jmapper, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof root !== "undefined" && root !== null) {
  require('source-map-support').install();
  expect = require('expect.js');
  Join = require('join');
  _ = require('underscore');
  configForTest = require('./config');
  Neo4j = require("../" + configForTest.srcFolder + "/index.js");
  _ref = new Neo4j({
    url: configForTest.neo4jURL,
    onConnectionError: function(err) {
      throw err;
    }
  }), Graph = _ref.Graph, Node = _ref.Node, Relationship = _ref.Relationship, Path = _ref.Path, Transaction = _ref.Transaction, Neo4jRestful = _ref.Neo4jRestful, helpers = _ref.helpers, client = _ref.client;
} else {
  _ = window._;
  configForTest = _.extend({
    doLog: false,
    wipeDatabase: false,
    neo4jURL: 'http://yourserver:0000/'
  }, configForTest || {});
  Join = window.Join;
  neo4jmapper = new window.Neo4jMapper(configForTest.neo4jURL);
  Graph = neo4jmapper.Graph, Node = neo4jmapper.Node, Relationship = neo4jmapper.Relationship, Path = neo4jmapper.Path, Transaction = neo4jmapper.Transaction, Neo4jRestful = neo4jmapper.Neo4jRestful, helpers = neo4jmapper.helpers, client = neo4jmapper.client;
  Neo4j = Neo4jMapper;
}

if (configForTest.doLog) {
  client.constructor.prototype.log = Graph.prototype.log = configForTest.doLog;
}

describe('Neo4jMapper (helpers)', function() {
  it('expect to generate md5 hashes', function() {
    return expect(helpers.md5('Hellö World!')).to.be.equal('909bba9bc963cd9f20d8d9e29d16c7f2');
  });
  it('escapeString', function() {
    var s;
    s = helpers.escapeString("'a test's'");
    expect(s).to.be.equal("a test\\'s");
    s = helpers.escapeString('"a test\'s"');
    expect(s).to.be.equal("a test\\'s");
    s = helpers.escapeString('a test\'s');
    expect(s).to.be.equal("a test\\'s");
    s = helpers.escapeString('""');
    expect(s).to.be.equal('\\"\\"');
    return expect(helpers.escapeString({})).to.be.an('object');
  });
  it('sortStringAndCallbackArguments', function() {
    var callback, string, _ref1, _ref2;
    _ref1 = helpers.sortStringAndCallbackArguments('string', function() {}), string = _ref1.string, callback = _ref1.callback;
    expect(string).to.be.equal('string');
    expect(callback).to.be.a('function');
    _ref2 = helpers.sortStringAndCallbackArguments(function() {}), string = _ref2.string, callback = _ref2.callback;
    expect(string).to.be(null);
    return expect(callback).to.be.a('function');
  });
  it('sortStringAndOptionsArguments', function() {
    var options, string, _ref1, _ref2, _ref3;
    _ref1 = helpers.sortStringAndOptionsArguments('string', {
      option: true
    }), string = _ref1.string, options = _ref1.options;
    expect(string).to.be.equal('string');
    expect(options.option).to.be.equal(true);
    _ref2 = helpers.sortStringAndOptionsArguments({
      option: true
    }), string = _ref2.string, options = _ref2.options;
    expect(string).to.be(null);
    expect(options.option).to.be.equal(true);
    _ref3 = helpers.sortStringAndOptionsArguments('string'), string = _ref3.string, options = _ref3.options;
    expect(string).to.be.equal('string');
    return expect(Object.keys(options)).to.have.length(0);
  });
  it('sortOptionsAndCallbackArguments', function() {
    var callback, options, _ref1, _ref2;
    _ref1 = helpers.sortOptionsAndCallbackArguments({
      option: true
    }, function() {}), options = _ref1.options, callback = _ref1.callback;
    expect(callback).to.be.a('function');
    expect(options.option).to.be.equal(true);
    _ref2 = helpers.sortOptionsAndCallbackArguments(function() {}), options = _ref2.options, callback = _ref2.callback;
    expect(callback).to.be.a('function');
    return expect(Object.keys(options)).to.have.length(0);
  });
  it('flattenObject', function() {
    expect(helpers.flattenObject({
      a: {
        b: true
      }
    })).to.be.eql({
      'a.b': true
    });
    expect(helpers.flattenObject({
      a: {
        b: null
      }
    })).to.be.eql({
      'a.b': null
    });
    expect(helpers.flattenObject({
      a: true,
      b: 0,
      c: false
    })).to.be.eql({
      a: true,
      b: 0,
      c: false
    });
    return expect(helpers.flattenObject({
      a: null,
      b: void 0
    })).to.be.eql({
      a: null,
      b: void 0
    });
  });
  it('isObjectLiteral', function() {
    expect(helpers.isObjectLiteral({})).to.be(true);
    expect(helpers.isObjectLiteral({
      a: '1'
    })).to.be(true);
    expect(helpers.isObjectLiteral(null)).to.be(false);
    return expect(helpers.isObjectLiteral()).to.be(false);
  });
  it('valueToStringForCypherQuery', function() {
    expect(helpers.valueToStringForCypherQuery(true)).to.be.equal('true');
    expect(helpers.valueToStringForCypherQuery(false)).to.be.equal('false');
    expect(helpers.valueToStringForCypherQuery(null)).to.be.equal('NULL');
    expect(helpers.valueToStringForCypherQuery(/^test$/i)).to.be.equal('^(?i)test$');
    expect(helpers.valueToStringForCypherQuery(0)).to.be.equal('0');
    expect(helpers.valueToStringForCypherQuery(123.45)).to.be.equal('123.45');
    expect(helpers.valueToStringForCypherQuery('string')).to.be.equal('string');
    expect(helpers.valueToStringForCypherQuery()).to.be.equal('NULL');
    expect(helpers.valueToStringForCypherQuery("unescaped\" value")).to.be.equal('unescaped\\" value');
    expect(helpers.valueToStringForCypherQuery("unescaped\' value")).to.be.equal("unescaped\\' value");
    expect(helpers.valueToStringForCypherQuery('"string"')).to.be.equal('string');
    return expect(helpers.valueToStringForCypherQuery("'string'")).to.be.equal('string');
  });
  it('escapeProperty', function() {
    expect(helpers.escapeProperty('n.name')).to.be.equal('n.`name`');
    expect(helpers.escapeProperty('node.name')).to.be.equal('node.`name`');
    expect(helpers.escapeProperty('`city.name`')).to.be.equal('`city.name`');
    expect(helpers.escapeProperty('node.`name`')).to.be.equal('node.`name`');
    return expect(helpers.escapeProperty('node.name?')).to.be.equal('node.`name`?');
  });
  it('serializeObjectForCypher', function() {
    var o;
    o = {
       name1: 'Philipp',
      name2: 123,
      "home`s": {
        europe: true
      },
      'node.`property`': 'whatever'
    };
    return expect(helpers.serializeObjectForCypher(o)).to.be.equal("{ `name1` : 'Philipp', `name2` : 123, homes.`europe` : true, node.`property` : 'whatever' }");
  });
  describe('constructorNameOfFunction', function() {
    return it('expect to get the correct constructor name', function() {
      var Person, node, _ref1;
      node = new Node;
      Person = (function(_super) {
        __extends(Person, _super);

        function Person() {
          _ref1 = Person.__super__.constructor.apply(this, arguments);
          return _ref1;
        }

        return Person;

      })(Node);
      var Movie = (function(Node) {

      function Movie() {
        // this is necessary to give the constructed node a name context
        this.init.apply(this, arguments);
      }

      _.extend(Movie.prototype, Node.prototype);

      Movie.prototype.label = Movie.prototype.constructor_name = 'Movie';

      Movie.prototype.fields = {
        defaults: {
          genre: 'Blockbuster'
        }
      };

      return Movie;
    })(Node);
      expect(helpers.constructorNameOfFunction(Movie)).to.be.equal('Movie');
      expect(helpers.constructorNameOfFunction(Person)).to.be.equal('Person');
      return expect(helpers.constructorNameOfFunction(node)).to.be.equal('Node');
    });
  });
  describe('extractAttributesFromCondition', function() {
    return it('expect to extract all attributes from a condition', function() {
      var attrs, condition;
      condition = [
        {
          $and: [
            {
              'n.name': /Alice/i
            }, {
              $or: [
                {
                  'n.email': "alice@home.com"
                }, {
                  $and: [
                    {
                      'n.email': "alice@home.de"
                    }, {
                      'n.country': "de_DE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ];
      attrs = helpers.extractAttributesFromCondition(condition);
      expect(attrs[0]).to.be('name');
      expect(attrs[1]).to.be('email');
      expect(attrs[2]).to.be('country');
      condition = [
        {
          'city': 'Berlin'
        }, {
          $and: [
            {
              'name': /^bob.+/i
            }, {
              $not: [
                {
                  'name': /^Bobby$/
                }
              ]
            }
          ]
        }
      ];
      attrs = helpers.extractAttributesFromCondition(condition);
      expect(attrs[0]).to.be('city');
      return expect(attrs[1]).to.be('name');
    });
  });
  return describe('conditionalParameterToString', function() {
    it('expect to leave a string as it is', function() {
      var condition;
      condition = "n.name = 'Alice' AND HAS(n.email)";
      return expect(new helpers.ConditionalParameters(condition).toString()).to.be.equal('( ' + condition + ' )');
    });
    it('expect to transform an key-value object to cypher query', function() {
      var condition, resultShouldBe;
      condition = [
        {
          "n.name": "Alice's"
        }, "HAS(n.email))"
      ];
      resultShouldBe = "( HAS (n.`name`) AND n.`name` = 'Alice\\'s' AND HAS(n.email)) )";
      return expect(new helpers.ConditionalParameters(condition, {
        valuesToParameters: false,
        identifier: 'n'
      }).toString()).to.be.equal(resultShouldBe);
    });
    it('expect to transform an key-value-object to with $OR and $AND operators', function() {
      var condition, resultShouldBe;
      resultShouldBe = "( ( HAS (n.`name`) AND n.`name` =~ '(?i)Alice' AND ( HAS (n.`email`) AND n.`email` =~ '^alice@home\\\\.com$' OR ( HAS (n.`email`) AND n.`email` = 'alice@home.de' AND HAS (n.`country`) AND n.`country` = 'de_DE' ) ) ) )";
      condition = [
        {
          $and: [
            {
              'n.name': /Alice/i
            }, {
              $or: [
                {
                  'n.email': /^alice@home\.com$/
                }, {
                  $and: [
                    {
                      'n.email': "alice@home.de"
                    }, {
                      'n.country': "de_DE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ];
      return expect(new helpers.ConditionalParameters(condition, {
        valuesToParameters: false
      }).toString()).to.be.equal(resultShouldBe);
    });
    it('expect to transform an key-value-object with identifier', function() {
      var condition, resultShouldBe;
      resultShouldBe = "( ( HAS (n.`name`) AND n.`name` =~ \'(?i)Alice\' AND HAS (n.`since`) AND r.`since` = \'years\' AND ( HAS (n.`email`) AND n.`email` = \'alice@home.com\' OR ( HAS (n.`email`) AND n.`email` = \'alice@home.de\' AND HAS (n.`country`) AND n.`country` = \'de_DE\' ) ) ) )";
      condition = [
        {
          $and: [
            {
              'n.name': /Alice/i
            }, {
              'r.since': 'years'
            }, {
              $or: [
                {
                  'n.email': "alice@home.com"
                }, {
                  $and: [
                    {
                      'email': "alice@home.de"
                    }, {
                      'country': "de_DE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ];
      return expect(new helpers.ConditionalParameters(condition, {
        identifier: 'n',
        valuesToParameters: false
      }).toString()).to.be.equal(resultShouldBe);
    });
    it('expect to use mathematical operators', function() {
      var condition, resultShouldBe;
      resultShouldBe = "( ( HAS (n.`name`) AND n.`name` =~ \'(?i)Alice\' AND HAS (n.`since`) AND r.`since` = \'years\' AND ( HAS (n.`email`) AND n.`email` = \'alice@home.com\' OR ( HAS (n.`email`) AND n.`email` = \'alice@home.de\' AND HAS (n.`country`) AND n.`country` = \'de_DE\' ) ) ) )";
      condition = [
        {
          $and: [
            {
              'n.name': /Alice/i
            }, {
              'r.since': 'years'
            }, {
              $or: [
                {
                  'n.email': "alice@home.com"
                }, {
                  $and: [
                    {
                      'email': "alice@home.de"
                    }, {
                      'country': "de_DE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ];
      return expect(new helpers.ConditionalParameters(condition, {
        identifier: 'n',
        valuesToParameters: false
      }).toString()).to.be.equal(resultShouldBe);
    });
    return it('expect to transform an key-value-object with parameters', function() {
      var con, condition;
      condition = [
        {
          $and: [
            {
              'n.name': /Alice/i
            }, {
              'r.since': 'years'
            }, {
              $or: [
                {
                  'n.email': "alice@home.com"
                }, {
                  $and: [
                    {
                      'email': "alice@home.de"
                    }, {
                      'country': "de_DE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ];
      con = new helpers.ConditionalParameters(condition, {
        identifier: 'n'
      });
      expect(con.toString()).to.be.equal("( ( HAS (n.`name`) AND n.`name` =~ {_value0_} AND HAS (n.`since`) AND r.`since` = {_value1_} AND ( HAS (n.`email`) AND n.`email` = {_value2_} OR ( HAS (n.`email`) AND n.`email` = {_value3_} AND HAS (n.`country`) AND n.`country` = {_value4_} ) ) ) )");
      expect(con.parametersCount()).to.be.equal(5);
      expect(con.values()[0]).to.be.equal('(?i)Alice');
      expect(con.values()[1]).to.be.equal('years');
      expect(con.values()[2]).to.be.equal('alice@home.com');
      expect(con.values()[3]).to.be.equal('alice@home.de');
      return expect(con.values()[4]).to.be.equal('de_DE');
    });
  });
});
